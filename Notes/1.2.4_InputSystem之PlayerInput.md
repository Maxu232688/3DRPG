# InputSystem之PlayerInput

## PlayerInput是什么

PlayerInput是InputSystem提供的专门用于接受玩家输入来处理自定义逻辑的组件

主要工作原理：

1. 配置输入文件(InputActions文件)
2. 通过PlayerInput关联配置文件，它会自动解析该配置文件
3. 关联对应的响应函数,处理对应逻辑

好处:\
不需要自己进行相关输入的逻辑书写\
通过配置文件即可配置想要监听的对应行为让我们专注于输入事件触发后的逻辑处理

省略去生成配置文件对应的代码的操作。

## 添加PlayerInput组件

AddComponent 添加 PlayerInput 即可

## PlayerInput参数相关

- Actions:行为（就是输入配置文件，拖到这里即可）
  - 一套输入动作和玩家相关联,帮助我们监听一些按键的输入
  - Default Control Scheme:默认启用哪一个控制方案
  - Default Actions Map:默认启用哪一个行为映射方案
- UI Input Module：由于使用的是新输入系统了，所以创建UGUI后EventSystem需要修改Standalone Input Module，点击其下方的 Replace with InputSystemUIInputModule即可，随后可以把EventSystem拖到这里，通过UI来控制一些内容。一般不需要。
- Camera:关联摄像机，当分屏设置时才需修改此选项
- Behavior:如何通知游戏对象上执行对应逻辑
  - SendMessage:将逻辑脚本挂载在和Playerlnput同一对象上,会通过SendMessage通知执行对应函数
  - BroadcastMessage:,将逻辑脚本挂载在其自身或子对象上。会通过BroadcastMessage通知执行对应函数
  - lnvoke UnityEvent Actions:通过拖拽脚本关联函数指明想要执行的函数逻辑
  - lnvoke CSharp Events:通过C#事件监听处理对应逻辑,通过获取Playerlnput进行事件监听

### 行为执行模式

上文 Behavior 中有四种行为执行模式，这里详细说明它们有什么含义。

**1. Send Messages**：

在自定义脚本中声明名为“On+行为名”的函数，没有参数或者参数类型为InputValue\
将该自定义脚本挂载到PlayerInput依附的对象上，当触发对应输入时会自动调用函数

并且还有默认的3个和设备相关的函数可以调用\
设备注册(当控制器从设备丢失中恢复并再次运行时会触发):OnDeviceRegained(PlayerInput input)\
设备丢失(玩家失去了分配给它的设备之一，例如,当无线设备耗尽电池时):OnDeviceLost(PlayerInput input)\
控制器切换:OnControlschanged(PlayerInput input)

假如我的InputActions中配置了Move的Action

```csharp
public void OnMove(InputValue value)
{
    print("Move");
    print(value.Get<Vector2>());
    print(value.isPressed);
}

public void OnDeviceLost(PlayerInput input)
{
    print("设备丢失");
}
```

然后将该脚本挂载到有PlayerInput组件的对象上，采用Send Message的方式即可调用这些函数。

**2. Broadcast Messages**：

基本和sendMessage规则一致\
唯一的区别是，自定义脚本不仅可以挂载在PlayerInput依附的对象上，还可以挂载在其子对象下

**3. Invoke Unity Events**：

该模式可以让我们在Inspector窗口上通过拖拽的形式关联响应函数\
但是注意：响应函数的参数类型需要改为`InputAction.callbackContext`\
选择后下方会出现一个Event选项卡，点卡即可看到配置好的操作。

```csharp
public void MyMove(InputAction.CallbackContext context)
{
    print("Move");
}
```

在对应Action下点击加号，拖动脚本到上面，在右边指明要执行哪个函数。\
这样的话控制移动的脚本就可以不用挂载在PlayerInput依附的对象上了。

**4. Invoke C\# Events**：

1. 获取PlayerInput组件
2. 获取对应事件进行委托函数添加
3. 当触发输入时会自动触发事件调用对应函数

```csharp
public PlayerInput input;

void Start()
{
    // 监听设备
    input.onDeviceLost += TestFun1;
    // 监听移动等操作
    input.onActionTriggered += TestFun2;
}

private void TestFun1(PlayerInput input)
{
    // ...
}

private void TestFun2(PlayerInput.CallbackContext context)
{
    // 不管什么类型的输入都会调用这里。
    switch (context.action.name)
    {
        case "Fire":
        //判断输入阶段，触发阶段生效
            if (context.phase == InputActionPhase.Performed)
            {
                print("Fire");
            }
            break;
        case "Look":
            print("Look at: " + context.ReadValue<Vector2>());
            break;
        //....
    }
}

```

要注意 InputAction.CallbackContext 和 InputValue 的使用\
建议使用第三种和第四种方式，效率较高。