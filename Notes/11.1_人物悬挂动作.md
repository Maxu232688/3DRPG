# 人物悬挂动作

首先，人物的攀爬有一个状态是挂在墙上。

那挂在墙上就是一个状态，我们需要去做这样一个状态。\
在Player\States下新建脚本LedgeHangingPlayerState

```csharp
public class LedgeHangingPlayerState : PlayerState
{
    // 人物挂在墙上的时候会有父对象，这里设置bool值来判断是否保留这个父对象
    protected bool m_keepParent;
    // 清除父对象的携程，我们要让player对象去开启携程，而不是这个状态开启携程
    protected Coroutine m_clearParentRoutine;
    protected const float k_clearParentDelay = 0.25f;

    protected override void OnEnter(Player entity)
    {
        // 在进入状态时，判断清除父对象携程是不是空的，如果不是空的，就要把这个携程停止
        if (m_clearParentRoutine != null)
        {
            entity.StopCoroutine(m_clearParentRoutine);
        }
        // 我们不知道人物接下来是要走了还是要接着在这个物体上爬，所以先把保留父对象设置为false
        m_keepParent = false;
        // skin 就是 lily 预制体里面的模型，这里就是要修改模型位置
        // entity.stats.current.ledgeHangingSkinOffset 是一个 Vector3 类型的变量，这个值没有修改过，所以是（0，0，0）
        // 那么这里就是将偏移量旋转到角色模型的方向来，然后给角色模型加上偏移量
        entity.skin.position += entity.transform.rotation * entity.stats.current.ledgeHangingSkinOffset;
        // 重设跳跃次数，这个函数没有实现，其实就是跳跃次数 = 0，挂在墙上的时候也能按下空格进行跳跃
        entity.ResetJumps();
    }

    protected override void OnExit(Player entity)
    {
        // 退出状态时，要进行父对象的清除，上文所说要player去开启携程清除父对象
        m_clearParentRoutine = entity.StartCoroutine(ClearParentRoutine(entity));
        // 既然都退出这个状态了，对模型的偏移就可以设置回去了，减去同方向的偏移量就行了
        entity.skin.position -= entity.transform.rotation * entity.stats.current.ledgeHangingSkinOffset;
    }
    // 这个函数看起来很恐怖，实际上就是纸老虎！
    protected override void OnStep(Player entity)
    {
        // 首先，这里已经进入了边缘攀爬的状态，也就是说我们一定是已经扒在边缘上了，我们需要向前发射球形射线和从头顶前方向下发射射线检测我们扒到的这个物体，以保证我们时刻都扒在物体上，如果检测不到了，说明物体消失了或者其他的什么情况，那就要掉下来。
        // 我们计算出球形射线的起点，player.position实际上就已经是player的中心点了，所以再加上半身高，再减去这个偏移量，也就是说这个点在头顶的下方。
        var sideOrigin = entity.position + Vector3.up * entity.height * 0.5f +
                         Vector3.down * entity.stats.current.ledgeSideHeightOffset;
        // 球形射线的半径，这是定好的一个参数
        var rayRadius = entity.stats.current.ledgeSideCollisionRadius;
        // 球形射线发射的距离，角色碰撞体半径 + 设定好的距离
        var rayDistance = entity.radius + entity.stats.current.ledgeSideMaxDistance;
        // 我们先来看下面的判断
        // 那么球形射线发射完了，前方的物体检测完了，还需要检测纵向的物体，从头顶前方的一个位置向下发射一条射线，它要碰撞到东西才能保证我们一直挂在边缘上
        // 这个偏移量是 一半身高 + 纵向偏移，注意这是个数字
        var ledgeTopHeightOffset = entity.height * 0.5f + entity.stats.current.ledgeMaxDownwardDistance;
        // 这个距离是 半径 + 前向偏移，注意也是个数字
        var ledgeTopMaxDistance = entity.radius + entity.stats.current.ledgeMaxForwardDistance;
        // 那么这个点就很明显了，就是角色的中心点先向上移动 ledgeTopHeightOffset 的距离，它现在已经离开头顶了；然后再向前移动 ledgeTopMaxDistance 的距离
        var topOrigin = entity.position + Vector3.up * ledgeTopHeightOffset +
                        entity.transform.forward * ledgeTopMaxDistance;
        // 这里发射了球形射线进行检测，碰到物体返回true，没碰到返回false，sideHit就是我们拿到的碰到物体的信息
        if (Physics.SphereCast(sideOrigin, rayRadius, entity.transform.forward, out var sideHit, rayDistance, entity.stats.current.ledgeHangingLayer, QueryTriggerInteraction.Ignore) 
        // 那么从头顶前方的这个点向下发射射线，检测碰到的物体
            && Physics.Raycast(topOrigin, Vector3.down, out var topHit, entity.height, entity.stats.current.ledgeHangingLayer, QueryTriggerInteraction.Ignore))
        {
            // 都检测到了，说明我们扒在物体边缘了
            // 此时 sideForward 是我们如果要扒在这个物体上时，面朝向应该在哪个方向，这就使用了球形射线与物体碰撞时的法线方向的反方向。
            // 法线方向垂直于被碰撞的物体表面，那么 负的 法线方向就是反过来垂直（面壁）
            var sideForward = -new Vector3(sideHit.normal.x, 0, sideHit.normal.z).normalized;
            // 这里我们拿到键盘输入的数据，这是为了我们能够在扒在物体上面的时候左右移动
            var inputDirection = entity.inputs.GetMovementDirection();
            // 我们需要检测左右移动时不能超过物体的边界，所以也需要发射一条射线，检测是否已经到达物体的左右边界。
            // 那么这个检测起始点就需要在发射球形射线的点基础上进行左右移动
            // 如果我们向右挪动，那么这个点就应该在角色的右肩膀上，如果向左移动，就应该在左肩膀上（形象的比喻一下）
            var ledgeSideOrigin = sideOrigin + entity.transform.right * Mathf.Sign(inputDirection.x) * entity.radius;
            // 角色扒在物体上时，它的position肯定是要在物体边缘下方的。因为position是角色的中心点，我们扒在物体上时，最高点是手，所以身体要下调这段距离。
            var ledgeHeight = topHit.point.y - entity.height * 0.5f;

            // 这两个参数是为了攀爬做的，攀爬是啥动作呢，就是人物挂在边缘的时候，按一下w键他就自己爬上去站在台子上面，所以我们要算一下我们要站的目标点合理不合理
            // 爬上去站的目标点的高度
            var destinationHeight = entity.height * 0.5f + Physics.defaultContactOffset;
            // 爬上去的目标点 是 从上往下的射线碰到的点 + 上面算出来的高度 + 向前偏移角色半径
            var climbDestination = topHit.point + Vector3.up * destinationHeight + entity.transform.forward * entity.radius;
            // 让角色面朝向攀爬的物体
            entity.FaceDirection(sideForward);
            // 如果检测到我们还在物体的内部，即没有达到左右边界，那就可以根据输入的数值给横向速度来改变角色左右的位置
            if (Physics.Raycast(ledgeSideOrigin, sideForward, rayDistance, entity.stats.current.ledgeHangingLayer, QueryTriggerInteraction.Ignore))
            {
                entity.lateralVelocity = entity.transform.right * inputDirection.x * entity.stats.current.ledgeMovementSpeed;
            }
            else // 如果已经到达边缘了，就停下来
            {
                entity.lateralVelocity = Vector3.zero;
            }
            // 由于位移的更改在状态更改之后，所以我们上面只改了速率，让位置更改的部分去根据速度改位置，我们这里就保证角色扒在边缘的位置的正确性，x和z就是被抓住物体边缘的平面坐标，y坐标就是我们上面所说的向下挪动了的一些位置，让玩家看起来更像是挂在边缘。最后减去的这个量，就是半径，胶囊体不能和这个物体重合，边缘相切就行了。
            entity.transform.position = new Vector3(sideHit.point.x, ledgeHeight, sideHit.point.z) - sideForward * entity.radius - entity.center;
            // 如果检测到按下了释放按钮（鼠标右键），那就让角色面朝物体反方向，切换到掉落状态，如果不切换到反方向，就又扒住了
            if (entity.inputs.GetReleaseLedgeDown())
            {
                entity.FaceDirection(-sideForward);
                entity.states.Change<FallPlayerState>();
            }
            // 如果检测到跳跃按钮，那就跳起来
            else if (entity.inputs.GetJumpDown())
            {
                entity.Jump(entity.stats.current.maxJumpHeight);
                entity.states.Change<FallPlayerState>();
            }
            // 最后如果 输入方向 z 大于 0 （即按了w） 且 能进行攀爬
            else if(inputDirection.z > 0 && entity.stats.current.canClimbLedge &&
            // 且 头顶射线碰到的这个物体 属于 能攀爬的物体中的一种
                    ((1 << topHit.collider.gameObject.layer) & entity.stats.current.ledgeClimbingLayer) != 0 &&
                    // 且 这个 攀爬的目标点合适
                    entity.FitsInPosition(climbDestination))
            {
                // 攀爬时父节点要保留，切换到攀爬的状态
                m_keepParent = true;
                entity.states.Change<LedgeClimbingPlayerState>();
                entity.playerEvents.OnLedgeClimbing?.Invoke();
            }
        }
        else
        {
            entity.states.Change<FallPlayerState>();
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
    }

    protected virtual IEnumerator ClearParentRoutine(Player player)
    {
        // 如果要保留父对象，就不做操作了，结束携程
        if (m_keepParent)
        {
            yield break;
        }
        
        // 否则等一下就清空父对象
        yield return new WaitForSeconds(k_clearParentDelay);

        player.transform.parent = null;
    }
}
```

那么这个状态是写好了，我们先来补充一些没有做的东西，再去做如何切换进这个状态

首先我们在PlayerInputManager中加上攀爬相关的动作检测

```csharp
protected InputAction m_releaseLedge;

protected virtual void CacheActions()
{
    ...
    m_releaseLedge = actions["ReleaseLedge"];
}

public virtual bool GetReleaseLedgeDown() => m_releaseLedge.WasPressedThisFrame();
```

然后我们补充一下PlayerStats

```csharp
[Header("Ledge Hanging Stats")] 
public bool canLedgeHang = true;
public LayerMask ledgeHangingLayer;
public Vector3 ledgeHangingSkinOffset;
public float ledgeMaxForwardDistance = 0.25f;
public float ledgeMaxDownwardDistance = 0.25f;
public float ledgeSideMaxDistance = 0.5f;
public float ledgeSideHeightOffset = 0.15f;
public float ledgeSideCollisionRadius = 0.25f;
public float ledgeMovementSpeed = 1.5f;

[Header("Ledge Climbing Stats")] 
public bool canClimbLedge = true;
public LayerMask ledgeClimbingLayer;
public Vector3 ledgeClimbingSkinOffset;
public float ledgeClimbingDuration = 1f;
```

随后我们在Player中进行状态的切换

```csharp
// 这就是角色的模型，在攀爬的时候要控制它的偏移
public Transform skin;
// 边缘检测，两个参数是最大向前检测距离和最大向下检测距离，不在这个范围内说明不能成功扒在物体边缘
protected virtual bool DetectingLedge(float forwardDistance, float downwardDistance, out RaycastHit ledgeHit)
{
    // 接触偏移量 是 默认接触偏移量 + 每帧位置移动量
    var contactOffset = Physics.defaultContactOffset + positionDelta;
    // 边缘最大距离 是 角色胶囊体半径 + 传入的向前检测最大距离
    var ledgeMaxDistance = radius + forwardDistance;
    // 边缘高度偏移 是 身高的一半 + 接触偏移量
    var ledgeHeightOffset = height * 0.5f + contactOffset;
    // 向上偏移 是 方向向上，长度为边缘高度偏移的向量
    var upwardOffset = transform.up * ledgeHeightOffset;
    // 向前偏移 是 方向向前，长度为边缘最大距离的向量
    var forwardOffset = transform.forward * ledgeMaxDistance;
    // 如果 从头顶向前方发射的射线检测到物体了（说明头顶还没高过物体边缘）
    if (Physics.Raycast(position + upwardOffset, transform.forward, ledgeMaxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
    // 或者 从 面前向上发射的射线检测到物体了（说明头顶上有东西挡住了）
    || Physics.Raycast(position + forwardOffset * 0.01f, transform.up, ledgeHeightOffset, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore))
    {
        // 那就不能悬挂
        ledgeHit = new RaycastHit();
        return false;
    }
    // 否则 从 头顶前方 向下发射一条射线，检测物体的上面，能碰到就说明可以挂，碰不到就挂不了
    var origin = position + upwardOffset + forwardOffset;
    var distance = downwardDistance + contactOffset;

    return Physics.Raycast(origin, Vector3.down, out ledgeHit, distance, stats.current.ledgeHangingLayer, QueryTriggerInteraction.Ignore);
}
// 边缘悬挂的检测
public virtual void LedgeGrab()
{
    // 当 角色可以挂在边缘时 且 角色已经在向下掉落了 且 手里没拿东西
    if (stats.current.canLedgeHang && velocity.y < 0 && !holding
    // 且 状态机里面包含悬挂状态
    && states.ContainsStateOfType(typeof(LedgeHangingPlayerState)) 
    // 且 边缘检测成功
    && DetectingLedge(stats.current.ledgeMaxForwardDistance, stats.current.ledgeMaxDownwardDistance, out var hit))
    {
        // 如果 边缘检测返回的物体是胶囊形 或 球形 的碰撞体，那就不能抓在上面，要滑下去
        if (!(hit.collider is CapsuleCollider) && !(hit.collider is SphereCollider))
        {
            // 否则就是能挂了
            // 边缘的最大距离 是 角色胶囊体半径 + 最大向前距离
            var ledgeDistance = radius + stats.current.ledgeMaxForwardDistance;
            // 侧向偏移 是 角色面朝向方向，长度为ledgeDistance的向量
            var lateralOffset = transform.forward * ledgeDistance;
            // 纵向偏移 是 向下的方向，长度为身高的一半
            var verticalOffset = Vector3.down * height * 0.5f - center;
            // 速率归零
            velocity = Vector3.zero;
            // 父节点设置为要挂上去的物体，如果这个物体不是Platform，那就不设置父对象
            transform.parent = hit.collider.CompareTag(GameTags.Platform) ? hit.transform : null;
            // 角色位置 移动到 射线监测点 减去 侧向偏移 加上 纵向偏移的位置
            // 这是将角色先挪到一个合适的位置，进入悬挂状态后要进行射线判断
            transform.position = hit.point - lateralOffset + verticalOffset;
            states.Change<LedgeHangingPlayerState>();
            playerEvents.OnLedgeGrabbed?.Invoke();
        }
    }
}

public virtual void ResetJumps() => jumpCounter = 0;
```

打开EntityStateManager

```csharp
// 检查状态中有没有扒在边缘的状态用到的
public virtual bool ContainsStateOfType(Type type) => m_states.ContainsKey(type);
```

打开Entity

```csharp
// 位置的移动量
public float positionDelta { get; protected set; }
// 上一帧的位置
public Vector3 lastPosition { get; set; }

protected virtual void LateUpdate()
{
    if (controller.enabled)
    {
        HandlePosition();
    }
}
// 检测每帧的移动量
protected virtual void HandlePosition()
{
    positionDelta = (position - lastPosition).magnitude;
    lastPosition = position;

}
// 看看点是否合适
public virtual bool FitsInPosition(Vector3 position)
{
    // 半径是 角色控制器半径 - 角色控制器的碰撞皮肤宽度
    var radius = controller.radius - controller.skinWidth;
    // 偏移量 是 身高的一半 - 半径 （即胶囊体圆柱部分高度的一半）
    var offset = height * 0.5f - radius;
    // 检测胶囊体的圆柱上部中心点 是 当前角色位置加上向上偏移量
    var top = position + Vector3.up * offset;
    // 检测胶囊体的圆柱下部中心点 是 当前角色位置加上向下偏移量
    var bottom = position - Vector3.up * offset;
    // 检查有没有物体和这个设定的胶囊体重合，没有重合的时候才能爬上去，不然你爬上去就被挡住了
    return !Physics.CheckCapsule(top, bottom, radius, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore);
}
```

最后我们在Player\States下新建脚本LedgeClimbingPlayerState

```csharp
public class LedgeClimbingPlayerState : PlayerState
{
    protected override void OnEnter(Player entity)
    {
    }

    protected override void OnExit(Player entity)
    {
    }

    protected override void OnStep(Player entity)
    {
    }

    public override void OnContact(Player entity, Collider other)
    {
    }
}
```

在Unity中，我们给Lily预制体中的Player的Skin拖上去Skin。\
PlayerStateManager的状态14 改为LedgeHangingPlayerState，15 改为LedgeClimbingPlayerState.\
打开PlayerStatsManager中的持久化Stats，修改General Stats 的 Gravity 为 49；（勾上后面说的那个 Auto Sync Transforms 可能就不用调整重力了）\
修改Ledge Hanging Stats的 Ledge Hanging Layer ，勾选Default，Camera Obstructor，Ignore Ledge Hanging。

打开Unity的 Edit -> Project Settings -> Physics ，勾选 Auto Sync Transforms，详情见文档勘误细节中的 5.攀爬错误。

运行，就能扒在台子边缘了，左右爬也没有问题。