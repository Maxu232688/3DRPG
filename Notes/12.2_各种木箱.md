# 各种木箱

具体怎么拖预制体这里就不细说了，按照课程里面拖或者按照原工程去拖都是可以的，我觉得对照着原工程拖比看课快。

做了很多预制体，上面的脚本这里列举一下。

漂浮脚本，金币啊人头啊生命值这类东西在浮空的时候应该上下浮动才好看

在Misc中，新建脚本Floater

```csharp
public class Floater : MonoBehaviour
{
    public float speed = 2f;
    public float amplitude = 0.5f;
    
    protected void LateUpdate()
    {
        // 就是通过sin函数来算它的y坐标
        var wave = Mathf.Sin(Time.time * speed) * amplitude;
        transform.position += transform.up * wave * Time.deltaTime;
    }
}
```

加重试次数要在GameController中去加，因为重试次数在Game里面储存

```csharp
public virtual void AddRetries(int amount) => m_game.retries += amount;
```

加生命值要去Health里面先给一个函数去加

```csharp
public virtual void Add(int amount)
{
    this.current += amount;
}
```

然后在Player下新建脚本PlayerController去控制

```csharp
public class PlayerController : MonoBehaviour
{
    protected Player m_player;

    public Player player
    {
        get
        {
            if (!m_player)
            {
                m_player = FindObjectOfType<Player>();
            }

            return m_player;
        }
    }
    
    public virtual void AddHealth(int amount) => player.health.Add(amount);
}
```

最后按照课程中拖拖挂挂，就行了。

---

这里我要对以前做好的东西进行一些修改。

我觉得箱子里面的金币这样的东西，在打破箱子以后老是乱飞，lifetime也很短，五秒钟你很多时候都追不上这个金币，所以设置一个落地次数，在第几次落地的时候停用物理，不让他走了。

于是在Collectable中：

```csharp
[Header("Stop Physics Settings")] 
public bool canStopPhysics;
public int stopPhysicsOnGroundTimes = 3;

protected int onGroundTimes = 0;

protected virtual void HandleSweep()
{
    var direction = m_velocity.normalized;
    var magnitude = m_velocity.magnitude;
    var distance = magnitude * Time.deltaTime;
    if (Physics.SphereCast(transform.position, collisionRadius, direction, out var hit, distance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore))
    {
        if (!hit.collider.CompareTag(GameTags.Player))
        {
            var bounceDirection = Vector3.Reflect(direction, hit.normal);
            m_velocity = bounceDirection * magnitude * bounciness;
            m_velocity.y = Mathf.Min(m_velocity.y, maxBounceYVelocity);
            m_audio.Stop();
            m_audio.PlayOneShot(collisionClip);
            // 加了这一句，判断一下接触到的物体是不是地面
            if (hit.normal == Vector3.up)
            {
                onGroundTimes++;
            }
            // 如果允许在几次碰撞后关闭物理，且关闭的次数已经达到了
            if (m_velocity.y <= minForceToStopPhysics || (onGroundTimes >= stopPhysicsOnGroundTimes && canStopPhysics))
            {
                usePhysics = false;
            }
        }
    }

    transform.position += m_velocity * Time.deltaTime;
}
```

这样金币在跳跃几次后，在接触地面第3次（设置几就是第几次）时停止运动。

然后我又对箱子进行了修改，做金属箱子的时候，要勾选碰到hazard就重生的选项，但是运行的时候一碰就直接飞回去了，看着很突兀，于是我就想播一下那个破坏的特效。在Pickable中：

```csharp
// 在播放特效的时候隐藏模型，然后重生的时候再显示出来
public MeshRenderer mesh;
// 要播放的特效
public ParticleSystem respawnParticle;
// 播放特效等待一段时间
public float particlePlayDuration = 1f;

protected virtual IEnumerator HazardRespawnRoutine()
{
    // 防止忘了拖模型进来导致脚本失效
    if (mesh != null)
    {
        // 碰到hazard先关掉模型，达到消失的效果
        mesh.enabled = false;
        // 然后播放特效
        if (respawnParticle != null)
        {
            respawnParticle.Play();
        }
        // 等一秒特效播完
        yield return new WaitForSeconds(particlePlayDuration);
    }
    // 再重生回去原来的地方
    Respawn();

    if (mesh != null)
    {
        // 显示模型
        mesh.enabled = true;
    }
    // 这里说一句为啥不用事件来实现播放特效的操作。
    // 因为事件是瞬间发送的，特效播放需要一点时间来呈现效果，所以用事件直接调用particle.play()的话就会导致箱子一瞬间回去原来地方，特效也跟着跑了
}

public virtual void Respawn()
{
    m_rigidbody.velocity = Vector3.zero;
    transform.parent = m_initialParent;
    transform.SetPositionAndRotation(m_initialPosition, m_initialRotation);
    m_rigidbody.isKinematic = m_collider.isTrigger = beingHold = false;
    if (respawnParticle != null)
    {
        // 加了一句，重生之后模拟掉地上那个感觉，播一下特效
        respawnParticle.Play();
    }
}

protected virtual void EvaluateHazardRespawn(Collider other)
{
    if (autoRespawn && respawnOnHitHazard && other.CompareTag(GameTags.Hazard))
    {
        // 改成用携程去重生
        StartCoroutine(HazardRespawnRoutine());
    }
}
```

然后普通的那些可破坏的箱子，就只能通过玩家来打烂吗？是不是也可以通过碰撞hazard被打烂呢？在Breakable中：

```csharp
public bool hazardCanBreak;

// 检测碰撞固体和非固体的hazard
protected void OnCollisionEnter(Collision other)
{
    if (hazardCanBreak && other.collider.CompareTag(GameTags.Hazard))
    {
        Break();
    }
}

protected void OnTriggerEnter(Collider other)
{
    if (hazardCanBreak && other.CompareTag(GameTags.Hazard))
    {
        Break();
    }
}
```