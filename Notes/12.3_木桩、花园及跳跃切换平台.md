# 木桩、花园及跳跃切换平台

木桩这里我改了一下Mover，其余和课程里面没什么区别，照着课程拖拽即可实现，具体操作不展示了

Mover：

```csharp
// 其实也没改啥，就是加了个scale的Offset，可以修改它的大小了，旋转的话我们有rotator
// 当然修改scale应该新建个脚本scaler实现，就是我懒得弄了
// 所以这段代码你不改也是一样的，改了不一定好，只是我对物体控制的一些常识罢了
public class Mover : MonoBehaviour
{
    public Vector3 positionOffset;
    public Vector3 scaleOffset;
    public float duration = 0.5f;
    public float resetDuration = 0.5f;
    
    protected Vector3 m_initialPosition;
    protected Vector3 m_initialScale;

    protected virtual IEnumerator ApplyOffsetRoutine(Vector3 posFrom, Vector3 posTo, Vector3 scaleFrom, Vector3 scaleTo, float duration)
    {
        var elapsedTime = 0f;
        while (elapsedTime < duration)
        {
            var t = elapsedTime / duration;
            transform.localPosition = Vector3.Lerp(posFrom, posTo, t);
            transform.localScale = Vector3.Lerp(scaleFrom, scaleTo, t);
            elapsedTime += Time.deltaTime;
            yield return null;
        }

        transform.localPosition = posTo;
        transform.localScale = scaleTo;
    }
    
    public virtual void ApplyOffset()
    {
        StopAllCoroutines();
        StartCoroutine(ApplyOffsetRoutine(m_initialPosition, m_initialPosition + positionOffset, m_initialScale, m_initialScale + scaleOffset, duration));
    }

    public virtual void Reset()
    {
        StopAllCoroutines();
        StartCoroutine(ApplyOffsetRoutine(transform.localPosition, m_initialPosition, transform.localScale, m_initialScale, resetDuration));
    }
    
    protected void Start()
    {
        m_initialPosition = transform.localPosition;
        m_initialScale = transform.localScale;
    }
}
```

这里要注意的是：\
挂上金币之后失活金币了，但是你重击这个木桩的时候没有蹦出金币来，是因为在Panel的Activate事件里面没加上这个监听，要记得去加监听

花园就更没啥可说的了，纯拖组件了，按照原工程里面拖更快。花园里面没有任何脚本，唯一要注意的点是使用的是Hidden的金币。

跳跃平台板依旧是根据原工程拖预制体，之后加入一个脚本

在Misc下新建脚本GridPlatform

```csharp
public class GridPlatform : MonoBehaviour
{
    // 旋转的那个板
    public Transform platform;
    // 旋转的时间
    public float rotationDuration = 0.5f;
    // 正面朝上还是反面朝上
    protected bool m_clockwise = true;
    
    protected IEnumerator MoveRoutine()
    {
        var elapsedTime = 0f;
        var rotationFrom = platform.localRotation;
        // 没啥好说的了，就是插值算旋转角度，正面朝上就转过去，反面朝上就转回来
        var rotationTo = Quaternion.Euler(0, 0, m_clockwise ? 180 : 0);
        m_clockwise = !m_clockwise;

        while (elapsedTime < rotationDuration)
        {
            elapsedTime += Time.deltaTime;
            platform.localRotation = Quaternion.Lerp(rotationFrom, rotationTo, elapsedTime / rotationDuration);
            yield return null;
        }
        // 注意别写错了
        platform.localRotation = rotationTo;
    }
    // 我们要实现这个旋转过去的这个动画，就得用携程，不然会卡住
    public virtual void Move()
    {
        StopAllCoroutines();
        StartCoroutine(MoveRoutine());
    }
    
    protected void Start()
    {
        // 根据玩家跳跃情况进行翻转，所以直接监听跳跃事件就行了
        FindObjectOfType<Player>().playerEvents.OnJump.AddListener(Move);
    }
}
```