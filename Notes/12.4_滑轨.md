# 滑轨

Window -> Package Manager搜索Splines，安装这个插件

按照课程拖轨道，注意课程中的组件Spline已经改名为Spline Container

把第12个layer命名为Unstable Surface，新建Tag：Interactive/Rail

在GameTags里面加上这个Tag

```csharp
public static string InteractiveRail = "Interactive/Rail";
```

那么就开始增加人物的滑轨状态，在Player/States下新建脚本RailGrindPlayerState

```csharp
public class RailGrindPlayerState : PlayerState
{
    protected bool m_backwards;
    protected float m_speed;
    protected float m_lastDashTime;
    
    protected override void OnEnter(Player entity)
    {
        // 进入滑轨状态时，我们要算一下角色的朝向，位置等信息，你要沿着滑轨移动，就得有方向，位置，旋转等等信息
        Evaluate(entity, out var point, out var forward, out var upward, out var t);
        // 更新玩家位置，进入滑轨状态了得把玩家吸到滑轨上
        UpdatePosition(entity, point, upward);
        // 是否反方向 要看player的面朝向和forward之间的夹角
        m_backwards = Vector3.Dot(entity.transform.forward, forward) < 0;
        // 在滑轨上的速度就是取一个最大值，看是玩家的速度大还是初始速度大
        m_speed = Mathf.Max(entity.lateralVelocity.magnitude, entity.stats.current.minGrindInitialSpeed);
        // 把玩家速度归零
        entity.velocity = Vector3.zero;
        // 开启自定义碰撞
        entity.UseCustomCollision(entity.stats.current.useCustomCollision);
    }

    protected override void OnExit(Player entity)
    {
        // 退出滑轨
        entity.ExitRail();
        // 关闭自定义碰撞
        entity.UseCustomCollision(false);
    }

    protected override void OnStep(Player entity)
    {
        // 只有跳跃能离开滑轨
        entity.Jump();
        // 在滑轨上时
        if (entity.onRails)
        {
            // 计算目标方向等数据
            Evaluate(entity, out var point, out var forward, out var upward, out var t);
            // 移动的方向要看玩家是否反向，反向就取反
            var direction = m_backwards ? -forward : forward;
            // 导轨有升高和降低，升高时要加上坡的力，降低时要加下坡的力
            var factor = Vector3.Dot(Vector3.up, direction);
            var multiplier = factor <= 0
                ? entity.stats.current.slopeDownwardForce
                : entity.stats.current.slopeUpwardForce;
            // 控制减速
            HandleDeceleration(entity);
            // 控制冲刺
            HandleDash(entity);
            // 如果应用上下坡的时候加减速
            if (entity.stats.current.applyGrindingSlopeFactor)
            {
                // 上面算的速度就加上
                m_speed -= factor * multiplier * Time.deltaTime;
            }
            // 但是不论怎么样上下坡的时候速度不能越界
            m_speed = Mathf.Clamp(m_speed, entity.stats.current.minGrindSpeed, entity.stats.current.grindTopSpeed);
            // 人物在导轨上面也得旋转
            RotateOnRail(entity, direction, upward);
            // 应用在导轨上的速度，让玩家沿导轨以m_speed进行移动
            entity.velocity = direction * m_speed;
            // 如果导轨是闭环的，或者t在0~0.9范围内
            if (entity.rails.Spline.Closed || (t > 0 && t < 0.9f))
            {
                // 重新设置位置，让玩家不要掉下去了
                UpdatePosition(entity, point, upward);
            }
        }
        else // 不在滑轨上时就掉落
        {
            entity.states.Change<FallPlayerState>();
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
    }
    // 返回参数有 在哪个点 向前的方向 向上的方向 与最近点对应的归一化插值率
    protected virtual void Evaluate(Player player, out Vector3 point, out Vector3 forward, out Vector3 upward, out float t)
    {
        // 起始点 是 将玩家位置转换到滑轨坐标系下的位置
        var origin = player.rails.transform.InverseTransformPoint(player.transform.position);
        // 计算滑轨上面离输入点最近的点，这个获取到的点就是我们在unity里面一个一个加的那个点，同时获取到与最近点对应的归一化插值率。
        SplineUtility.GetNearestPoint(player.rails.Spline, origin, out var nearest, out t);
        // 将最近的点坐标转换到世界坐标系下
        point = player.rails.transform.TransformPoint(nearest);
        // 向前的方向就应该是 计算世界空间中样条线上点 t 的切向量 所得的方向
        forward = Vector3.Normalize(player.rails.EvaluateTangent(t));
        // 向上的方向就应该是 计算世界空间中样条线上点 t 的向上向量
        upward = Vector3.Normalize(player.rails.EvaluateUpVector(t));
        // 总之，我们拿到了玩家在滑轨上时最近的要去的点，向前的方向，向上的方向，还有这个t
    }

    protected virtual void UpdatePosition(Player player, Vector3 point, Vector3 upward)
    {
        // 就是把player吸到轨道上面，加一个offset不要穿模
        player.transform.position = point + upward * GetDistanceToRail(player);
    }

    protected virtual float GetDistanceToRail(Player player)
    {
        // 这个offset就是 player 身高的一半 + 导轨中心到边缘的距离，就是算player的中心点应该在哪
        return player.originHeight * 0.5f + player.stats.current.grindRadiusOffset;
    }

    protected virtual void RotateOnRail(Player player, Vector3 forward, Vector3 upward)
    {
        // 前方不是没有值的时候
        if (forward != Vector3.zero)
        {
            // 让玩家面朝向forward方向，以transform.up为旋转轴
            player.transform.rotation = Quaternion.LookRotation(forward, player.transform.up);
        }
        // 玩家的头顶朝向也需要根据导轨的旋转进行改变，导轨倾斜了玩家的头顶方向也要倾斜
        player.transform.rotation = Quaternion.FromToRotation(player.transform.up, upward) * player.transform.rotation;
    }

    protected virtual void HandleDeceleration(Player player)
    {
        // 如果能刹车 且 检测到玩家按了刹车键
        if (player.stats.current.canGrindBrake && player.inputs.GetGrindBrake())
        {
            // 每帧刹车减多少速度
            var decelerationDelta = player.stats.current.grindBrakeDeceleration * Time.deltaTime;
            // 减速
            m_speed = Mathf.MoveTowards(m_speed, 0, decelerationDelta);
        }
    }

    protected virtual void HandleDash(Player player)
    {
        // 如果玩家能在导轨上冲刺 且 检测到冲刺按下 且 不在冲刺冷却时间里面
        if (player.stats.current.canGrindDash && player.inputs.GetDashDown() && Time.time >= m_lastDashTime + player.stats.current.grindDashCoolDown)
        {
            // 重置冲刺冷却时间，然后冲刺，就是加上冲刺所得的速度
            m_lastDashTime = Time.time;
            m_speed = player.stats.current.grindDashForce;
            player.playerEvents.OnDashStarted?.Invoke();
        }
    }
}
```

计算滑轨上最近的点：\
[Method GetNearestPoint](https://docs.unity3d.com/Packages/com.unity.splines@2.5/api/UnityEngine.Splines.SplineUtility.GetNearestPoint.html)

我们首先要知道玩家在哪个导轨上，才能进入导轨状态去算点，方向等数据，所以

Entity：

```csharp
// 在哪条导轨上
public SplineContainer rails { get; protected set; }
// 是否在导轨上
public bool onRails { get; set; }
// 刚体，这是为了在导轨上使用自定义碰撞保留的
protected Rigidbody m_rigidbody;

protected virtual void InitializeRigidbody()
{
    // 初始化刚体，当在导轨上时，要加上这个
    m_rigidbody = gameObject.AddComponent<Rigidbody>();
    m_rigidbody.isKinematic = true;
    
}

protected virtual void Update()
{
    if (controller.enabled || m_collider != null)
    {
        HandleState();
        HandleController();
        // 加上这个函数来判断导轨状态
        HandleSpline();
        HandleGround();
        HandleContacts();
        OnUpdate();
    }
}

protected virtual void HandleSpline()
{
    // 这个是因为 不是所有的实体都是上半身和下半身一样高的
    var distance = (height * 0.5f) + height * 0.5f;
    // 检测一下，向下的distance距离里面有没有导轨
    if (SphereCast(-transform.up, distance, out var hit) && hit.collider.CompareTag(GameTags.InteractiveRail))
    {
        // 如果没在导轨上且在下落
        if (!onRails && verticalVelocity.y <= 0)
        {
            // 进入导轨
            EnterRail(hit.collider.GetComponent<SplineContainer>());
        }
    }
    else // 否则退出导轨
    {
        ExitRail();
    }
}

public virtual void UseCustomCollision(bool value)
{
    // 首先停掉角色控制器，这里面的碰撞我们就不用了，相反关闭自定义碰撞的时候要开启
    controller.enabled = !value;

    if (value)
    {
        // 重新初始化碰撞体和刚体
        InitializeCollider();
        InitializeRigidbody();
    }
    else // 否则就是销毁掉自定义的碰撞体和刚体
    {
        Destroy(m_collider);
        Destroy(m_rigidbody);
    }
}

protected virtual void EnterRail(SplineContainer rails)
{
    // 进入轨道时要求不在轨道上
    if (!onRails)
    {
        onRails = true;
        // 获取到轨道
        this.rails = rails;
        entityEvents.OnRailEnter?.Invoke();
    }
}

public virtual void ExitRail()
{
    if (onRails)
    {
        onRails = false;
        entityEvents.OnRailExit?.Invoke();
    }
}
```

player中

```csharp
protected override void Awake()
{
    base.Awake();
    InitializedInputs();
    InitializedStats();
    InitializeHealth();
    InitializeTag();
    InitializeRespawn();
    // 这里监听一下落地状态，重置空中的一些操作的限制
    entityEvents.OnGroundEnter.AddListener(() =>
    {
        ResetJumps();
        ResetAirSpins();
    });
    // 同样的，进入轨道了之后也要重置限制，同时切换到轨道滑行状态
    entityEvents.OnRailEnter.AddListener(() =>
    {
        ResetJumps();
        ResetAirSpins();
        StartGrind();
    });
}

public virtual void Jump()
{
    var canMultiJump = (jumpCounter > 0) && (jumpCounter < stats.current.multiJumps);
    var canCoyoteJump = (jumpCounter == 0) && (Time.time < lastGroundTime + stats.current.coyoteJumpThreshold);

    // 这里不要忘了加上onRails的时候也能检测跳跃
    if ((isGrounded || onRails || canMultiJump || canCoyoteJump) && !holding)
    {
        if (inputs.GetJumpDown())
        {
            Jump(stats.current.maxJumpHeight);
        }
    } 

    if (inputs.GetJumpUp() && (jumpCounter > 0) && verticalVelocity.y > stats.current.minJumpHeight)
    {
        verticalVelocity = Vector3.up * stats.current.minJumpHeight;
    }
}

public virtual void StartGrind() => states.Change<RailGrindPlayerState>();

public virtual void ResetJumps() => jumpCounter = 0;

public virtual void ResetAirSpins() => airSpinCounter = 0;
    
```

我们在PlayerStats里面又加了好多属性

```csharp
[Header("Motion Stats")] 
...
// 新加入的
public float slopeUpwardForce = 25f;
public float slopeDownwardForce = 28f;
[Header("Rail Grinding Stats")] 
public bool useCustomCollision = true;
public float grindRadiusOffset = 0.26f;
public float minGrindInitialSpeed = 10f;
public float minGrindSpeed = 5f;
public float grindTopSpeed = 25f;
[Header("Rail Grinding Brake")] 
public bool canGrindBrake = true;
public float grindBrakeDeceleration = 10f;
[Header("Rail Grinding Dash Stats")] 
public bool canGrindDash = true;
public bool applyGrindingSlopeFactor = true;
public float grindDashCoolDown = 0.5f;
public float grindDashForce = 25f;
```

再去PlayerInputManager里面加上用到的按键检测

```csharp
protected InputAction m_grindBrake;
protected InputAction m_dash;

protected virtual void CacheActions()
{
    ...
    m_grindBrake = actions["Grind Brake"];
    m_dash = actions["Dash"];
}

public virtual bool GetGrindBrake() => m_grindBrake.WasPressedThisFrame();

public virtual bool GetDashDown() => m_dash.WasPressedThisFrame();
```

在导轨上滑动也有特效，在PlayerParticle里面要进行控制

```csharp
public ParticleSystem dashDust;
public ParticleSystem speedTrails;
public ParticleSystem grindTrails;

protected virtual void HandleDashParticle()
{
    Play(dashDust);
    Play(speedTrails);
}

protected virtual void HandleRailParticle()
{
    if (m_player.onRails)
    {
        Play(grindTrails);
    }
    else
    {
        Stop(grindTrails, true);
    }
}

protected void Start()
{
    ...
    m_player.playerEvents.OnDashStarted.AddListener(HandleDashParticle);
    m_player.playerEvents.OnDashEnd.AddListener(() => Stop(speedTrails, true));
}

protected virtual void Update()
{
    HandleWalkParticle();
    HandleRailParticle();
}

```

在Unity中，要记得把滑轨设置为Rail的Tag，同时设置为Unstable Surface 的layer。\
Lily预制体中，修改第19个状态为滑轨状态。\
PlayerParticles里面要加入一些特效，按照原工程中去制作特效的预制体。那么这里就制作了三个剩下的特效，拖给脚本上。