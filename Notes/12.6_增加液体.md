# 增加液体

首先是增加泥浆，按照原工程去拖拽预制体

在Misc下新建脚本 Volume

```csharp
public class Volume : MonoBehaviour
{
    public UnityEvent OnEnter;
    public UnityEvent OnExit;

    public AudioClip enterClip;
    public AudioClip exitClip;
    
    protected Collider m_collider;
    protected AudioSource m_audio;
    
    protected virtual void InitializeCollider()
    {
        m_collider = GetComponent<Collider>();
        // 液体当然要是trigger
        m_collider.isTrigger = true;
    }

    protected virtual void InitializeAudioSource()
    {
        if (!TryGetComponent(out m_audio))
        {
            m_audio = gameObject.AddComponent<AudioSource>();
        }

        m_audio.spatialBlend = 0.5f;
    }
    
    protected void Start()
    {
        // 初始化碰撞体和audioSource
        InitializeCollider();
        InitializeAudioSource();
    }

    protected void OnTriggerEnter(Collider other)
    {
        // 进入液体时，满足 头顶不在液体中 或者 脚底不在液体中
        if (!m_collider.bounds.Contains(other.bounds.max) || !m_collider.bounds.Contains(other.bounds.min))
        {
            // 播放进入音效
            m_audio.PlayOneShot(enterClip);
            OnEnter?.Invoke();
        }
    }

    protected void OnTriggerExit(Collider other)
    {
        // 退出时只需要 完全不包含实体的位置
        if (!m_collider.bounds.Contains(other.transform.position))
        {
            m_audio.PlayOneShot(exitClip);
            OnExit?.Invoke();
        }
    }
}
```

AudioSource.spatialBlend：

设置 3D 空间化计算（衰减、多普勒效应等）对该 AudioSource 的影响程度。0.0 使声音变成全 2D 效果，1.0 使其变成全 3D。\
除了确定将该 AudioSource 处理为 2D 还是 3D 源以外，该属性对于在这两种模式之间进行变换也很有用。\
3D 空间计算在确定立体声平移后进行，可以配合 panStereo 使用。\
对于在靠近监听器的过程中应逐渐变成正常 2D 效果的声音来说，在这两种模式间变换非常有用。

在Entity中新建脚本 EntityVolumeEffect

```csharp
public class EntityVolumeEffect : MonoBehaviour
{
    public float velocityConversion = 1f;
    public float accelerationMultiplier = 1f;
    public float topSpeedMultiplier = 1f;
    public float decelerationMultiplier = 1f;
    public float turningDragMultiplier = 1f;
    public float gravityMultiplier = 1f;
    
    protected Collider m_collider;

    protected void Start()
    {
        m_collider = GetComponent<Collider>();
        m_collider.isTrigger = true;
    }

    // 这里就是定义了一堆在液体中需要改变的阻力等等，在沼泽中要有费力的感觉
    protected void OnTriggerEnter(Collider other)
    {
        if (other.TryGetComponent(out Entity entity))
        {
            entity.velocity *= velocityConversion;
            entity.accelerationMultiplier = accelerationMultiplier;
            entity.topSpeedMultiplier = topSpeedMultiplier;
            entity.decelerationMultiplier = decelerationMultiplier;
            entity.turningDragMultiplier = turningDragMultiplier;
            entity.gravityMultiplier = gravityMultiplier;
        }
    }
    // 离开了自然要恢复
    protected void OnTriggerExit(Collider other)
    {
        if (other.TryGetComponent(out Entity entity))
        {
            entity.accelerationMultiplier = 1f;
            entity.topSpeedMultiplier = 1f;
            entity.decelerationMultiplier = 1f;
            entity.turningDragMultiplier = 1f;
            entity.gravityMultiplier = 1f;
        }
    }
}
```

把这两个挂到mud预制体上，按照原工程调参，即可实现在泥浆中的费力感和进入退出音效。

---

同样的方式再围一个水池，要深一点，按照原工程拖上预制体，挂上Volume。

先来定义状态数据 PlayerStats

```csharp
[Header("Swimming Stats")] 
public float waterConversion = 0.35f;
public float waterRotationSpeed = 360f;
public float waterUpwardForce = 8f;
public float waterJumpHeight = 15f;
public float waterTurningDrag = 2.5f;
public float swimAcceleration = 4f;
public float swimDeceleration = 3f;
public float swimTopSpeed = 4f;
public float swimDiveForce = 15f;
```

然后加入潜水按钮的检测

```csharp
protected InputAction m_dive;

protected virtual void CacheActions()
{
    ...
    m_dive = actions["Dive"];
}

public virtual bool GetDive() => m_dive.IsPressed();
```

在PlayerState下新建脚本 SwimPlayerState

```csharp
public class SwimPlayerState : PlayerState
{
    // 进入状态时，要将速度改成水里的速度
    protected override void OnEnter(Player entity)
    {
        entity.velocity *= entity.stats.current.waterConversion;
    }

    protected override void OnExit(Player entity)
    {
    }

    protected override void OnStep(Player entity)
    {
        // 如果在水里
        if (entity.onWater)
        {
            // 获取到相机方向，要让玩家按照在水中的系数进行移动和旋转
            var inputDirection = entity.inputs.GetMovementCameraDirection();
            entity.WaterAcceleration(inputDirection);
            entity.WaterFaceDirection(entity.lateralVelocity);
            // 如果 玩家在水面下面
            if (entity.position.y < entity.water.bounds.max.y)
            {
                // 触底了就再不能往下降了
                if (entity.isGrounded)
                {
                    entity.verticalVelocity = Vector3.zero;
                }
                // 浮力，让他每帧往上浮
                entity.verticalVelocity += Vector3.up * entity.stats.current.waterUpwardForce * Time.deltaTime;
            }
            else // 在水面上
            {
                // 那也不能再往上了
                entity.verticalVelocity = Vector3.zero;
                // 检测到跳跃按下，那就按照水中跳跃的系数让他跳起来，但是脱离水面以后一定时fall的状态
                if (entity.inputs.GetJumpDown())
                {
                    entity.Jump(entity.stats.current.waterJumpHeight);
                    entity.states.Change<FallPlayerState>();
                }
            }
            // 如果在水里面但没有触底 且 按下了潜水键
            if (!entity.isGrounded && entity.inputs.GetDive())
            {
                // 那就给他施加向下的力，潜水下去
                entity.verticalVelocity += Vector3.down * entity.stats.current.swimDiveForce * Time.deltaTime;
            }
            // 没有移动输入了，就减速
            if (inputDirection.sqrMagnitude == 0)
            {
                entity.Decelerate(entity.stats.current.swimDeceleration);
            }
        }
        else // 不在水里就退出状态
        {
            entity.states.Change<WalkPlayerState>();
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
        // 这是我们在写走路状态的时候就做好的函数，在水里的时候如果顶到一些可以移动的物体，要能推动它们
        entity.PushRigidbody(other);
    }
}
```

那么状态该怎么进入呢？在Player中：

```csharp
// 记录一下到底在哪个水里面
public Collider water { get; protected set; }
// 离开水面的偏移量
protected const float k_waterExitOffset = 0.25f;

protected void OnTriggerStay(Collider other)
{
    // 检测到在和Trigger接触时，看看是不是和水解除了
    if (other.CompareTag(GameTags.VolumeWater))
    {
        // 如果是和水接触且不在水里，且水已经包含玩家的位置了
        if (!onWater && other.bounds.Contains(unsizePosition))
        {
            // 进入水里
            EnterWater(other);
        }
        else if (onWater) // 否则不在水里的时候
        {
            // 设定一个脱离的坐标
            var exitPoint = position + Vector3.down * k_waterExitOffset;
            // 不包含这个偏移坐标，就退出水里
            if (!other.bounds.Contains(exitPoint))
            {
                ExitWater();
            }
        }
    }
}

public virtual void WaterAcceleration(Vector3 direction)
{
    // 这就是按在水里的系数进行加速
    Accelerate(direction, stats.current.waterTurningDrag, stats.current.swimAcceleration, stats.current.swimTopSpeed);
}

public virtual void WaterFaceDirection(Vector3 direction)
{
    // 按水里系数减速
    FaceDirection(direction, stats.current.waterRotationSpeed);
}

public virtual void EnterWater(Collider water)
{
    // 进入水里，不在水里且血量没空的时候，才能进去
    if (!onWater && !health.isEmpty)
    {
        onWater = true;
        // 手里不能拿东西
        Throw();
        this.water = water;
        states.Change<SwimPlayerState>();
    }
}

public virtual void ExitWater()
{
    if (onWater)
    {
        onWater = false;
    }
}
```

在PlayerStateManager的第8个状态加入游泳状态，跳入水池就能游泳了。