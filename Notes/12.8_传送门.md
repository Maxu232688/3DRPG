# 传送门

先按照原工程去拖预制体，把传送门的粒子特效做好，一红一蓝。

在Misc下新建脚本 Portal

```csharp
public class Portal : MonoBehaviour
{
    public Portal exit;
    public bool useFlash = true;
    public float exitOffset = 1f;
    public AudioClip teleportClip;
    
    protected Collider m_collider;
    protected AudioSource m_audio;
    protected PlayerCamera m_camera;

    public Vector3 position => transform.position;
    public Vector3 forward => transform.forward;
    
    protected void Start()
    {
        m_collider = GetComponent<Collider>();
        m_audio = GetComponent<AudioSource>();
        m_camera = FindObjectOfType<PlayerCamera>();
        m_collider.isTrigger = true;
    }
    // 当进入传送门时
    protected void OnTriggerEnter(Collider other)
    {
        // 存在对向出口，且是player接触到的传送门
        if (exit && other.TryGetComponent(out Player player))
        {
            // 计算player的y值与传送门的y值之间的插值，传送过去之后要让player在正确的y值上
            var yOffset = player.unsizePosition.y - transform.position.y;
            // 传送过去，加上这个插值
            player.transform.position = exit.position + Vector3.up * yOffset;
            // 更改player朝向，出口方向
            player.FaceDirection(exit.forward);
            // 重置相机
            m_camera.Reset();
            // 获取相机方向
            var inputDirection = player.inputs.GetMovementCameraDirection();
            // 如果相机方向和出口传送门方向反向
            if (Vector3.Dot(inputDirection, exit.forward) < 0)
            {
                // 修改玩家朝向，反过来
                player.FaceDirectionSmooth(-exit.forward);
            }
            // 把player挪出传送门的trigger范围以免无限传送
            player.transform.position += player.transform.forward * exit.exitOffset;
            // 按新方向重置速度
            player.lateralVelocity = player.transform.forward * player.lateralVelocity.magnitude;
            // 如果传送的时候要闪一下屏幕
            if (useFlash)
            {
                // 触发这个闪屏效果
                Flash.instance?.Trigger();
            }
            // 播放传送门音效
            m_audio.PlayOneShot(teleportClip);
        }
    }
}
```

在Misc下新建脚本 Flash

```csharp
public class Flash : Singleton<Flash>
{
    public float duration = 0.1f;
    public float fadeDuration = 0.5f;
    protected Image image;
    
    protected void Start()
    {
        image = GetComponent<Image>();
    }

    public void Trigger()
    {
        Trigger(duration, fadeDuration);
    }

    public void Trigger(float duration, float fadeDuration)
    {
        StopAllCoroutines();
        StartCoroutine(Routine(duration, fadeDuration));
    }
    // 开启携程，达到一个渐变的效果
    protected virtual IEnumerator Routine(float duration, float fadeDuration)
    {
        var elapsedTime = 0f;
        var color = image.color;

        color.a = 1;
        image.color = color;

        yield return new WaitForSeconds(duration);

        while (elapsedTime < fadeDuration)
        {
            color.a = Mathf.Lerp(1, 0, elapsedTime / fadeDuration);
            elapsedTime += Time.deltaTime;
            image.color = color;

            yield return null;
        }

        color.a = 0;
        image.color = color;
    }
}
```

Flash 要挂在_GAME_下的Flash上面\
给做好的传送门挂上Portal，拖好exit，就能互相传送了。