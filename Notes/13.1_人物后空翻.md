# 人物后空翻

如果你做了14节，当时懵懵懂懂的，没看明白这是在干啥，现在终于派上用场了，是后空翻。

那么什么状态能进到后空翻里面呢？是刹车状态，就是你走得很快的时候按一下反方向键的那一点点时间里面按下空格，就能后空翻了。

在此之前，我们需要在PlayerStats里面添加一些内容

```csharp
// 这里相较14节的内容有部分修改
[Header("Backflip Stats")] 
public bool canBackflip = true;
public bool backflipLockMovement = true;
public float backflipJumpHeight = 23f;
public float backflipGravity = 35f;
public float backflipTurningDrag = 2.5f;
public float backflipAirAcceleration = 12f;
public float backflipTopSpeed = 7.5f;
public float backflipBackwardForce = 4f;
public float backflipBackwardTurnForce = 8f;
```

然后在PlayerInputManager里面实现一个工具函数

```csharp
// 这是为了在后空翻时锁定移动操作，不锁定移动会出问题
public virtual void LockMovementDirection(float duration = 0.25f)
{
    m_movementDirectionUnlockTime = Time.time + duration;
}
```

在Player/States下新建脚本 BackflipPlayerState，如果你做了14节内容，直接在里面改就行

```csharp
public class BackflipPlayerState : PlayerState
{
    protected override void OnEnter(Player entity)
    {
        // 当然后空翻也算是一种特殊的跳，后空翻之后不能连跳，所以把跳跃次数设置为1
        entity.SetJumps(1);
        entity.playerEvents.OnJump?.Invoke();
        // 进入后空翻状态了，就锁定位移操作
        if (entity.stats.current.backflipLockMovement)
        {
            entity.inputs.LockMovementDirection();
        }
    }

    protected override void OnExit(Player entity)
    {
    }

    protected override void OnStep(Player entity)
    {
        // 如果做了14节，这里就是小修小改，后空翻时受重力影响，同时要进行后空翻自己的位移
        entity.Gravity(entity.stats.current.backflipGravity);
        entity.BackflipAcceleration();
        // 如果落地了，那就站好
        if (entity.isGrounded)
        {
            entity.lateralVelocity = Vector3.zero;
            entity.states.Change<IdlePlayerStates>();
        } // 如果没落地，还在下落，那就可以触发连招
        else if (entity.verticalVelocity.y < 0)
        {
            entity.Spin();
            entity.StompAttack();
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
        // 后空翻碰到东西的话看看能不能给推开
        entity.PushRigidbody(other);
    }
}
```

那么在Player中需要对它用到的一些函数进行实现，同样的，如果你做了14节内容，就只是小修小改

```csharp
public virtual void Backflip(float force)
{
    // 能后空翻 且 手里没拿东西
    if (stats.current.canBackflip && !holding)
    {
        // 设定角色的速度
        verticalVelocity = Vector3.up * stats.current.backflipJumpHeight;
        lateralVelocity = -transform.forward * force;
        // 切换到后空翻状态
        states.Change<BackflipPlayerState>();
        playerEvents.OnBackflip?.Invoke();
    }
}

public virtual void SetJumps(int amount) => jumpCounter = amount;
// 后空翻自己的位移行为
public virtual void BackflipAcceleration()
{
    var direction = inputs.GetMovementCameraDirection();
    Accelerate(direction, stats.current.backflipTurningDrag, stats.current.backflipAirAcceleration, stats.current.backflipTopSpeed);
}
```

什么时候进入后空翻状态上面已经说了，所以在BrakePlayerState中：

```csharp
protected override void OnStep(Player entity)
{
    var inputDirection = entity.inputs.GetMovementCameraDirection();
    // 当目前输入方向与角色面朝向相反时 按下跳跃键
    if (entity.stats.current.canBackflip && 
        Vector3.Dot(inputDirection, entity.transform.forward) < 0 &&
        entity.inputs.GetJumpDown())
    {
        // 后空翻
        entity.Backflip(entity.stats.current.backflipBackwardTurnForce);
    }
    else
    {
        // 否则就是刹车状态的检测
        entity.SnapToGround();
        entity.Jump();
        entity.Fall();
        entity.Decelerate();
        
        if (entity.lateralVelocity.sqrMagnitude == 0)
        {
            entity.states.Change<IdlePlayerStates>();
        }
    }
}
```

在Lily预制体中的State里面，第16个是后空翻状态。

设置好运行就能后空翻了。