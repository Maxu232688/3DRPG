# 人物蹲伏与爬行

在Player/States下新建脚本 CrouchPlayerState

```csharp
public class CrouchPlayerState : PlayerState
{
    // 蹲伏时，人物的碰撞体高度需要降低
    protected override void OnEnter(Player entity)
    {
        entity.ResizeCollider(entity.stats.current.crouchHeight);
    }
    // 退出的时候要恢复
    protected override void OnExit(Player entity)
    {
        entity.ResizeCollider(entity.originHeight);
    }

    protected override void OnStep(Player entity)
    {
        entity.Gravity();
        entity.SnapToGround();
        entity.Fall();
        // 走路的时候蹲下来了就是减速
        entity.Decelerate(entity.stats.current.crouchFriction);
        // 获取输入方向
        var inputDirection = entity.inputs.GetMovementDirection();
        // 如果按了蹲伏键 或者 玩家此时不能站起来
        if (entity.inputs.GetCrouchAndCrawl() || !entity.canStandUp)
        {
            // 当输入方向有效 且 玩家手里没拿东西
            if (inputDirection.sqrMagnitude > 0 && !entity.holding)
            {
                // 如果 玩家此时速度为0
                if (entity.lateralVelocity.sqrMagnitude == 0)
                {
                    // 切换另一个状态，我们还没做，就是蹲着走路
                    entity.states.Change<CrawlingPlayerState>();
                }
            }
            else if (entity.inputs.GetJumpDown()) // 如果蹲下的时候按下了空格
            {
                // 可以后空翻，但跳起来的高度比站着跳低
                entity.Backflip(entity.stats.current.backflipBackwardForce);
            }
        }
        else // 没蹲着就idle
        {
            entity.states.Change<IdlePlayerStates>();
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
    }
}
```

那么在PlayerStats里面补充两个属性

```csharp
[Header("Crouch Stats")] 
public float crouchHeight = 1f;
public float crouchFriction = 10f;
```

在PlayerInputManager里面加上蹲伏键的检测

```csharp
protected InputAction m_crouch;

protected virtual void CacheActions()
{
    ...
    m_crouch = actions["Crouch"];
}

public virtual bool GetCrouchAndCrawl() => m_crouch.IsPressed();
```

在Player里实现修改碰撞体高度的函数

```csharp
public virtual void ResizeCollider(float height)
{
    // 重新计算碰撞体高度，并重新计算碰撞体中心
    var delta = height - this.height;
    controller.height = height;
    controller.center += Vector3.up * delta * 0.5f;
}
// 这里我没有第二次封装，感觉没什么必要
public virtual bool canStandUp => !SphereCast(Vector3.up, originHeight, out _);
```

什么时候进入蹲伏状态呢？在Idle状态和Walk状态里面进行添加

Idle

```csharp
    protected override void OnStep(Player entity)
    {
        ...

        if (inputDirection.sqrMagnitude > 0 || entity.lateralVelocity.sqrMagnitude > 0)
        {
            entity.states.Change<WalkPlayerState>();
        } // 在最后加上一个新的判断即可
        else if (entity.inputs.GetCrouchAndCrawl())
        {
            entity.states.Change<CrouchPlayerState>();
        }
    }
```

Walk：

```csharp
    protected override void OnStep(Player entity)
    {
        ...
        // 这里直接在最后加一个判断就行了
        if (entity.inputs.GetCrouchAndCrawl())
        {
            entity.states.Change<CrouchPlayerState>();
        }
    }
```

在Lily预制体中，第9个state是蹲伏状态。

---

在Player/States下新建脚本 CrawlingPlayerState

```csharp
public class CrawlingPlayerState : PlayerState
{
    // 爬行和蹲伏是一样的，需要重新设置碰撞体
    protected override void OnEnter(Player entity)
    {
        entity.ResizeCollider(entity.stats.current.crouchHeight);
    }

    protected override void OnExit(Player entity)
    {
        entity.ResizeCollider(entity.originHeight);
    }

    protected override void OnStep(Player entity)
    {
        entity.Gravity();
        entity.SnapToGround();
        entity.Jump(); // 我觉得这里有问题，头顶有东西的时候按跳不就坏了
        entity.Fall();
        // 注意输入方向不要写错了
        var inputDirection = entity.inputs.GetMovementCameraDirection();

        if (entity.inputs.GetCrouchAndCrawl() || !entity.canStandUp)
        {
            if (inputDirection.sqrMagnitude > 0) // 输入有效
            {
                // 以爬行的参数加速度
                entity.CrawlingAccelerate(inputDirection);
                // 改变面朝向
                entity.FaceDirectionSmooth(entity.lateralVelocity);
            }
            else // 无效就减速
            {
                entity.Decelerate(entity.stats.current.crawlingFriction);
            }
        }
        else // 能站起来了就站起来
        {
            entity.states.Change<IdlePlayerStates>();
        }

    }

    public override void OnContact(Player entity, Collider other)
    {
    }
}
```

在PlayerStats中增加一些参数

```csharp
[Header("Crawling Stats")] 
public float crawlingAcceleration = 8f;
public float crawlingFriction = 32f;
public float crawlingTopSpeed = 2.5f;
public float crawlingTurningSpeed = 3f;
```

在Player中实现以爬行参数前进的函数

```csharp
public virtual void CrawlingAccelerate(Vector3 direction)
{
    Accelerate(direction, stats.current.crawlingTurningSpeed, stats.current.crawlingAcceleration, stats.current.crawlingTopSpeed);
}
```

在Lily预制体中，第10个state是爬行状态

此时运行，就实现了这些功能