# 人物滑行

在空中时才有可能滑行，在制作之前，现在PlayerStats里面加一些参数

```csharp
[Header("Motion Stats")] 
// 加上这两个，之后斜坡相关的判定会用到
public bool applySlopeFactor = true;
...
public float slopeFriction = 18f;

[Header("Air Dive Stats")] 
public bool canAirDive = true;
public bool applyDiveSlopeFactor = true;
public float airDiveForwardForce = 16f;
public float airDiveFriction = 32f;
public float airDiveSlopeFriction = 12f;
public float airDiveGroundLeapHeight = 10f;
public float airDiveRotationSpeed = 45f;
```

在PlayerInputManager里面也加上按键的检测

```csharp
protected InputAction m_airDive;

protected virtual void CacheActions()
{
    ...
    m_airDive = actions["AirDive"];
}

public virtual bool GetAirDive() => m_airDive.WasPressedThisFrame();
```

在Player/States下新建脚本 AirDivePlayerState

```csharp
public class AirDivePlayerState : PlayerState
{
    protected override void OnEnter(Player entity)
    {
        // 空中滑行状态进入时，先把玩家速度清空
        entity.velocity = Vector3.zero;
        // 给玩家设置新的速度
        entity.lateralVelocity = entity.transform.forward * entity.stats.current.airDiveForwardForce;
    }

    protected override void OnExit(Player entity)
    {
    }

    protected override void OnStep(Player entity)
    {
        // 要检测重力和跳跃，但是一般来说都是先跳起来再滑行，这里跳跃也跳不起来，除非掉下来的时候滑行，才能在空中进行跳跃
        entity.Gravity();
        entity.Jump();
        // 如果允许斜坡滑行
        if (entity.stats.current.applyDiveSlopeFactor)
        {
            // 计算斜坡滑行
            entity.SlopeFactor(entity.stats.current.slopeUpwardForce, entity.stats.current.slopeDownwardForce);
        }
        // 设置玩家朝向为行进的方向
        entity.FaceDirection(entity.lateralVelocity);
        // 如果落地了
        if (entity.isGrounded)
        {
            // 获取输入方向
            var inputDirection = entity.inputs.GetMovementCameraDirection();
            // 输入方向在玩家坐标系下的本地坐标
            var localInputDirection = entity.transform.InverseTransformDirection(inputDirection);
            // 旋转值
            var rotation = localInputDirection.x * entity.stats.current.airDiveRotationSpeed * Time.deltaTime;
            // 加速方向绕y轴旋转
            entity.lateralVelocity = Quaternion.Euler(0, rotation, 0) * entity.lateralVelocity;

            // 总的就是要把方向旋转到输入方向去

            // 如果在坡上
            if (entity.OnSlopingGround())
            {
                // 以斜坡摩擦力减速
                entity.Decelerate(entity.stats.current.airDiveSlopeFriction);
            }
            else // 否则
            {
                // 以空中摩擦力减速
                entity.Decelerate(entity.stats.current.airDiveFriction);
                // 当速度衰减为0时
                if (entity.lateralVelocity.sqrMagnitude == 0)
                {
                    // 让玩家获得一个垂直速度，并进行掉落
                    entity.verticalVelocity = Vector3.up * entity.stats.current.airDiveGroundLeapHeight;
                    entity.states.Change<FallPlayerState>();
                }
            }
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
    }
}

```

在Player中：

```csharp
// 这里原工程里放到Entity类里面了，但是课里面在Player类里，都一样，史莱姆也不会滑行
protected readonly float m_slopingGroundAngle = 20f;

public virtual void AirDive()
{
    // 什么时候能进入滑行状态，满足这一堆条件就可以
    if (stats.current.canAirDive && !isGrounded && !holding && inputs.GetAirDive())
    {
        states.Change<AirDivePlayerState>();
        playerEvents.OnAirDive?.Invoke();
    }
}

public virtual void SlopeFactor(float upwardForce, float downwardForce)
{
    // 斜坡滑行，如果不在地上 或者 不是在坡上，就不属于这个函数计算的内容
    if (!isGrounded || !OnSlopingGround())
    {
        return;
    }
    // 算一下斜面法线方向在垂直向上的方向上的投影长度，即垂直向上方向与斜面法线方向的点积
    var factor = Vector3.Dot(Vector3.up, groundNormal);
    // 要滑行的坡往上走就是 false，坡往下走就是 true
    var downwards = Vector3.Dot(localSlopeDirection, lateralVelocity) > 0;
    // 获取对应的倍乘系数
    var multiplier = downwards ? downwardForce : upwardForce;
    // 计算在坡度上面获取到的速度
    var delta = factor * multiplier * Time.deltaTime;
    // 按照下坡方向给速度，面朝上坡肯定获得负速度，要减速，面朝下坡就是正的
    lateralVelocity += localSlopeDirection * delta;
}

public virtual void RegularSlopeFactor()
{
    // 在斜坡上走路判定用到的
    if (stats.current.applySlopeFactor)
    {
        SlopeFactor(stats.current.slopeUpwardForce, stats.current.slopeDownwardForce);
    }
}

public virtual bool OnSlopingGround()
{
    // 是不是在斜坡上，首先就是在地上，然后地面角大于设定值
    if (isGrounded && groundAngle > m_slopingGroundAngle)
    {
        // 发射射线检测，从角色本身出发，向下发射一条 height * 2f 长度的射线检测
        if (Physics.Raycast(transform.position, -transform.up, out var hit, height * 2f, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore))
        {
            // 如果碰到东西了，检测一下坡度是否大于设定值，大于的话就是在斜坡上，否则不是
            return Vector3.Angle(hit.normal, Vector3.up) > m_slopingGroundAngle;
        }
        else // 没碰到说明坡度很大
        {
            return true;
        }
    }

    return false;
}
```

什么时候能切换进这个状态呢？

在Fall中：

```csharp
protected override void OnStep(Player entity)
{
    ...
    entity.StompAttack();

    // 加上这句
    entity.AirDive();
    ...
}
```

在Spin中

```csharp
    protected override void OnStep(Player entity)
    {
        entity.Gravity();
        entity.SnapToGround();
        // 加上
        entity.AirDive();
        ...
    }
```

在 Backflip中

```csharp
protected override void OnStep(Player entity)
{
    entity.Gravity(entity.stats.current.backflipGravity);
    entity.BackflipAcceleration();

    if (entity.isGrounded)
    {
        entity.lateralVelocity = Vector3.zero;
        entity.states.Change<IdlePlayerStates>();
    }
    else if (entity.verticalVelocity.y < 0)
    {
        entity.Spin();
        // 加上
        entity.AirDive();
        entity.StompAttack();
    }
}
```

在Lily预制体中，AirDive是第12个State

在Walk中：

```csharp
protected override void OnStep(Player entity)
{
    ...
    // 加上
    entity.RegularSlopeFactor();
    
    var inputDirection = entity.inputs.GetMovementCameraDirection();
    ...
}
```

在idle中

```csharp
    protected override void OnStep(Player entity)
    {
        ...
        // 加上
        entity.RegularSlopeFactor();

        var inputDirection = entity.inputs.GetMovementDirection();
        ...
    }
```

这两步是为了站在斜坡上走到斜坡上也受到坡度影响