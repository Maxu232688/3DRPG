# 滑翔伞

拖预制体就不用说了，具体看一下代码

在Misc下新建脚本Glider

```csharp
public class Glider : MonoBehaviour
{
    // 那两个轨道特效
    public TrailRenderer[] trails;
    // 展开滑翔伞要用的时间
    public float scaleDuration = 0.7f;

    [Header("Audio Settings")] 
    public AudioClip openAudio;
    public AudioClip closeAudio;

    protected Player player;
    protected AudioSource m_audio;

    protected virtual void InitializePlayer()
    {
        if (!player)
        {
            player = GetComponentInParent<Player>();
        }
    }

    protected virtual void InitializeAudio()
    {
        if (!TryGetComponent(out m_audio))
        {
            m_audio = gameObject.AddComponent<AudioSource>();
        }
    }

    protected virtual void InitializeCallbacks()
    {
        // 监听滑翔伞状态以打开或关闭滑翔伞及播放对应的音效
        player.playerEvents.OnGlidingStart.AddListener(ShowGlider);
        player.playerEvents.OnGlidingStop.AddListener(HideGlider);
    }

    protected virtual void InitializeGlider()
    {
        // 初始化滑翔伞，首先关掉轨道特效，然后把滑翔伞的scale设置为0
        SetTrailsEmitting(false);
        transform.localScale = Vector3.zero;
    }

    protected void Start()
    {
        InitializePlayer();
        InitializeAudio();
        InitializeCallbacks();
        InitializeGlider();
    }

    protected virtual void ShowGlider()
    {
        // 打开滑翔伞，用携程来实现动画，不然会卡住
        StopAllCoroutines();
        StartCoroutine(ScaleGliderRoutine(Vector3.zero, Vector3.one));
        SetTrailsEmitting(true);
        m_audio.PlayOneShot(openAudio);
    }

    protected virtual void HideGlider()
    {
        // 关闭滑翔伞，就是反过来
        StopAllCoroutines();
        StartCoroutine(ScaleGliderRoutine(Vector3.one, Vector3.zero));
        SetTrailsEmitting(false);
        m_audio.PlayOneShot(closeAudio);
    }

    protected virtual void SetTrailsEmitting(bool value)
    {
        // 这就是播放轨道特效的
        if (trails == null) 
        {
            return;
        }

        foreach (var trail in trails)
        {
            trail.emitting = value;
        }
    }

    protected IEnumerator ScaleGliderRoutine(Vector3 fromScale, Vector3 toScale)
    {
        // 插值缩放滑翔伞
        var time = 0f;
        transform.localScale = fromScale;

        while (time < scaleDuration)
        {
            var scale = Vector3.Lerp(fromScale, toScale, time / scaleDuration);
            transform.transform.localScale = scale;
            time += Time.deltaTime;
            yield return null;
        }

        transform.localScale = toScale;
    }
}
```

在PlayerStats里面加入一些属性

```csharp
[Header("Gliding Stats")] 
public bool canGlide = true;
public float glidingGravity = 10f;
public float glidingMaxFallSpeed = 2f;
public float glidingTurningDrag = 8f;
```

在PlayerInputManager中加入监听滑翔伞操作的函数

```csharp
protected InputAction m_glide;

protected virtual void CacheActions()
{
    ...
    m_glide = actions["Glide"];
}
// 注意这里别写错了
public virtual bool GetGlide() => m_glide.IsPressed();
```

在Player/States下新建脚本 GlidingPlayerState

```csharp
public class GlidingPlayerState : PlayerState
{
    
    protected override void OnEnter(Player entity)
    {
        // 进入滑翔伞状态时，把玩家的垂直速度设为0
        entity.verticalVelocity = Vector3.zero;
        entity.playerEvents.OnGlidingStart?.Invoke();
    }

    protected override void OnExit(Player entity)
    {
        entity.playerEvents.OnGlidingStop?.Invoke();
    }

    protected override void OnStep(Player entity)
    {
        var inputDirection = entity.inputs.GetMovementCameraDirection();
        // 滑翔伞状态下，要对重力进行特殊处理，我们要降落的慢一点
        HandleGlidingGravity(entity);
        // 朝向移动方向
        entity.FaceDirection(entity.lateralVelocity);
        // 以滑翔伞的参数移动
        entity.Accelerate(inputDirection, entity.stats.current.glidingTurningDrag, entity.stats.current.airAcceleration, entity.stats.current.topSpeed);
        // 有可能在空中抓到物体边缘，检测一下
        entity.LedgeGrab();
        // 落地了就切换到idle
        if (entity.isGrounded)
        {
            entity.states.Change<IdlePlayerStates>();
        }
        else if (!entity.inputs.GetGlide()) // 不打开滑翔伞了就fall
        {
            entity.states.Change<FallPlayerState>();
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
        
    }

    protected virtual void HandleGlidingGravity(Player player)
    {
        // 单独计算一下 垂直速度
        var yVelocity = player.verticalVelocity.y;
        // 用glide的重力进行计算
        yVelocity -= player.stats.current.glidingGravity * Time.deltaTime;
        // 当然最大不能超过规定值
        yVelocity = Mathf.Max(yVelocity, -player.stats.current.glidingMaxFallSpeed);
        // 赋值
        player.verticalVelocity = new Vector3(0, yVelocity, 0);
    }
}
```

状态做好了，在Player中写出调用它的入口

```csharp
public virtual void Glide()
{
    // 不在地上 按了滑翔伞的键 在下落 能打开滑翔伞
    if (!isGrounded && inputs.GetGlide() && verticalVelocity.y <= 0 && stats.current.canGlide)
    {
        states.Change<GlidingPlayerState>();
    }
}
```

那什么状态可以进到滑翔伞状态呢？

Fall

```csharp
    protected override void OnStep(Player entity)
    {
        ...
        entity.AirDive();
        // 加上
        entity.Glide();
        ...
    }
```

Backflip

```csharp
    protected override void OnStep(Player entity)
    {
        ...
        else if (entity.verticalVelocity.y < 0)
        {
            entity.Spin();
            entity.AirDive();
            entity.StompAttack();
            // 加上
            entity.Glide();
        }
    }
```

滑翔伞状态是Lily预制体中的第17个