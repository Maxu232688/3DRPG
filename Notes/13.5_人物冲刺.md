# 人物冲刺

在Player/States下新建脚本 DashPlayerState

```csharp
public class DashPlayerState : PlayerState
{
    protected override void OnEnter(Player entity)
    {
        // 进入冲刺状态时，清零玩家速度
        entity.verticalVelocity = Vector3.zero;
        // 给玩家向前的冲刺速度
        entity.lateralVelocity = entity.transform.forward * entity.stats.current.dashForce;
        entity.playerEvents.OnDashStarted?.Invoke();
    }

    protected override void OnExit(Player entity)
    {
        // 冲刺结束时，要将速度控制在最大速度内
        entity.lateralVelocity = Vector3.ClampMagnitude(entity.lateralVelocity, entity.stats.current.topSpeed);
        entity.playerEvents.OnDashEnd?.Invoke();
    }

    protected override void OnStep(Player entity)
    {
        // 冲刺时检测跳跃
        entity.Jump();
        // 如果冲刺的时间已经超过了规定时间
        if (timeSinceEntered > entity.stats.current.dashDuration)
        {
            // 在地面就walk
            if (entity.isGrounded)
            {
                entity.states.Change<WalkPlayerState>();
            }
            else // 不在地面就fall
            {
                entity.states.Change<FallPlayerState>();
            }
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
        entity.PushRigidbody(other);
    }
}
```

那么在PlayerStats中加入一些参数

```csharp
[Header("Dash Stats")] 
public bool canAirDash = true;
public bool canGroundDash = true;
public float dashForce = 25f;
public float dashDuration = 0.3f;
public float groundDashCoolDown = 0.5f;
public int allowedAirDashTimes = 1;
```

在Player中实现进入Dash的入口

```csharp
public int airDashCounter { get; protected set; }
public float lastDashTime { get; protected set; }

protected override void Awake()
{
    ...
    entityEvents.OnGroundEnter.AddListener(() =>
    {
        ...
        // 加上重置空中dash的函数
        ResetAirDash();
    });
    
    entityEvents.OnRailEnter.AddListener(() =>
    {
        ...
        ResetAirDash();
        StartGrind();
    });
}

public virtual void Dash()
{
    // 什么时候能在空中冲刺？
    // 属性允许，人物不在地面，空中冲刺次数没达到上限
    var canAirDash = stats.current.canAirDash && !isGrounded && airDashCounter < stats.current.allowedAirDashTimes;
    // 什么时候允许地面冲刺？
    // 属性允许，人物在地面，没有在冲刺冷却时间内
    var canGroundDash = stats.current.canGroundDash && isGrounded &&
                        Time.time - lastDashTime > stats.current.groundDashCoolDown;
    // 如果满足冲刺条件
    if (inputs.GetDashDown() && (canAirDash || canGroundDash))
    {
        // 不在地面时空中冲刺次数加一
        if (!isGrounded)
        {
            airDashCounter++;
        }

        lastDashTime = Time.time;
        states.Change<DashPlayerState>();
    }
}

public virtual void ResetAirDash() => airDashCounter = 0;
```

在 Fall 状态中

```csharp
protected override void OnStep(Player entity)
{
    ...
    entity.Dash();
    
    ...
}
```

Walk

```csharp
    protected override void OnStep(Player entity)
    {
        ...
        entity.Dash();
        
        var inputDirection = entity.inputs.GetMovementCameraDirection();

        ...
    }
```

在LedgeHangingPlayerState中，修复一些bug，重置没有归零的计数器

```csharp
    protected override void OnEnter(Player entity)
    {
        ...
        // 加上这两个
        entity.ResetAirDash();
        entity.ResetAirSpins();
    }
```

Dash状态在Lily预制体中是第18个