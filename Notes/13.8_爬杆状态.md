# 爬杆状态

杆子的制作就不多说了

在Player/States下新建脚本 PoleClimbingPlayerState

```csharp
public class PoleClimbingPlayerState : PlayerState
{
    // 爬杆的时候要吸附在杆子上面，然后还要能左右转

    // 杆子的半径
    protected float m_collisionRadius;
    
    protected override void OnEnter(Player entity)
    {
        // 进入爬杆状态，那就重设这一堆东西
        entity.ResetJumps();
        entity.ResetAirDash();
        entity.ResetAirSpins();
        // 速度设置为0
        entity.velocity = Vector3.zero;
        // 获取玩家位置到杆子中心的朝向
        entity.pole.GetDirectionToPole(entity.transform, out m_collisionRadius);
        // 给模型设置偏移量，在杆子上面不要穿模
        entity.skin.position += entity.transform.rotation * entity.stats.current.poleClimbSkinOffset;
    }

    protected override void OnExit(Player entity)
    {
        // 当然退出时要把偏移量去掉
        entity.skin.position -= entity.transform.rotation * entity.stats.current.poleClimbSkinOffset;
    }

    protected override void OnStep(Player entity)
    {
        // 获取玩家到杆子中心的朝向
        var poleDirection = entity.pole.GetDirectionToPole(entity.transform);
        // 获取输入方向
        var inputDirection = entity.inputs.GetMovementDirection();
        // 玩家应当面向杆子中心
        entity.FaceDirection(poleDirection);
        // 玩家现在任何的水平速度都要围绕着杆子进行设置，也就是只能在杆子上左右旋转，输入方向的x轴就是ad键
        entity.lateralVelocity = entity.transform.right * inputDirection.x * entity.stats.current.poleClimbRotationSpeed;
        // 如果有向上爬的输入（ws）
        if (inputDirection.z != 0)
        {
            var speed = inputDirection.z > 0
                ? entity.stats.current.poleClimbUpSpeed
                : entity.stats.current.poleClimbDownSpeed;
            entity.verticalVelocity = Vector3.up * speed;
            // 向上爬就给向上的速度，向下爬就向下的速度
        }
        else // 没有输入那就没速度
        {
            entity.verticalVelocity = Vector3.zero;
        }
        // 检测跳跃，跳跃要沿着杆子中心方向的反方向去跳，与蹬墙跳相似
        if (entity.inputs.GetJumpDown())
        {
            entity.FaceDirection(-poleDirection);
            entity.DirectionalJump(-poleDirection, entity.stats.current.poleClimbJumpHeight, entity.stats.current.poleClimbJumpHeight);
            entity.states.Change<FallPlayerState>();
        }
        // 顺着杆子溜到地上了，就站地上
        if (entity.isGrounded)
        {
            entity.states.Change<IdlePlayerStates>();
        }
        // 这里计算的是杆子的最上部和最下部都有一些不能爬上去的区域
        var offset = entity.height * 0.5f + entity.center.y;
        var center = new Vector3(entity.pole.center.x, entity.transform.position.y, entity.pole.center.z);
        var position = center - poleDirection * m_collisionRadius;
        // 将玩家的位置钳制在可用区域内
        entity.transform.position = entity.pole.ClampPointToPoleHeight(position, offset);
    }

    public override void OnContact(Player entity, Collider other)
    {
    }
}
```

在Misc中新建脚本 Pole

```csharp
public class Pole : MonoBehaviour
{
    // 杆子是个胶囊体碰撞体
    public CapsuleCollider collider { get; protected set; }
    // 杆子的中心点
    public Vector3 center => transform.position;
    protected void Awake()
    {
        tag = GameTags.Pole;
        collider = GetComponent<CapsuleCollider>();
    }

    public Vector3 GetDirectionToPole(Transform other)
    {
        return GetDirectionToPole(other, out _);
    }

    public Vector3 GetDirectionToPole(Transform other, out float distance)
    {
        // 返回other到杆子中心的方向
        var target = new Vector3(center.x, other.position.y, center.z) - other.position;
        distance = target.magnitude; 
        return target / distance;
    }
    // 将数据限制在杆子顶部-offset和杆子底部+offset的范围内
    public Vector3 ClampPointToPoleHeight(Vector3 point, float offset)
    {
        var minHeight = collider.bounds.min.y + offset;
        var maxHeight = collider.bounds.max.y - offset;
        var clampedHeight = Mathf.Clamp(point.y, minHeight, maxHeight);
        return new Vector3(point.x, clampedHeight, point.z);
    }
}
```

在Player中加入爬杆状态的入口

```csharp
public Pole pole { get; protected set; }

public virtual void GrabPole(Collider other)
{
    if (stats.current.canPoleClimb && velocity.y <= 0 && !holding && other.TryGetComponent(out Pole pole))
    {
        this.pole = pole;
        states.Change<PoleClimbingPlayerState>();
    }
}
```

GameTags里面加上杆子的tag，同时别忘了在unity中也要加上这个tag

```csharp
public static string Pole = "Pole";
```

PlayerStats里面要加上爬杆的这些属性

```csharp
[Header("Pole Climb Stats")] 
public bool canPoleClimb = true;
public Vector3 poleClimbSkinOffset;
public float poleClimbUpSpeed = 3f;
public float poleClimbDownSpeed = 8f;
public float poleClimbRotationSpeed = 2f;
public float poleClimbJumpDistance = 8f;
public float poleClimbJumpHeight = 15f;
```

什么状态下才能进入爬杆状态呢？

AirDive

```csharp
    public override void OnContact(Player entity, Collider other)
    {
        if (!entity.isGrounded)
        {
            entity.WallDrag(other);
            entity.GrabPole(other);
        }
    }
```

Backflip，Dash，Fall

```csharp
    public override void OnContact(Player entity, Collider other)
    {
        entity.PushRigidbody(other);
        entity.WallDrag(other);
        entity.GrabPole(other);
    }
```

Gliding

```csharp
    public override void OnContact(Player entity, Collider other)
    {
        entity.WallDrag(other);
        entity.GrabPole(other);
    }
```

Lily预制体中爬杆状态是第7个

到此，游戏功能全部实现完毕。至于后续的打安卓包往上面加虚拟摇杆，我只能说那个摇杆的手感奇差无比，手机上也不好使，自己按照原工程做一做就行了，基本都是拖ui，代码量就一点点，看一眼就懂了。