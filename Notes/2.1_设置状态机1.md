# 设置状态机

经历了千辛万苦我们终于学会了InputSystem，现在可以回到项目了。\
目前我们的项目文件如图所示

![image](./images/3_Floders.jpg)

我们在Scripts文件夹下创建了PlayerInputActions，并且创建了一个PlayerInputManager脚本。\
当然你可以使用资源中提供的InputActions配置文件，但是我是自己新建了一个。

**嫌麻烦就用提供好的，想自己手搓就新建一个，但是自己手搓最后还是要照着已经给的一个个添加，容易忘了加操作就别自己手搓了，但是我已经手搓了，就懒得再改了，其实就是修改CharacterController里面对应的文件就行了，如果你看了之前的InputSystem介绍，应该很清楚在哪里替换**

---

在PlayerInputActions中创建一个GamePlay操作组，增加一个名称为Movement的Action，设置为Value类型，监听Vector2数据。绑定wasd方向键即可。\
此时打开我们之前创建好的预制体，将PlayerInputManager脚本挂上去。

随后我们在脚本中添加如下内容：

```csharp
using UnityEngine.InputSystem;

public class PlayerInputManager : MonoBehaviour
{
    public InputActionAsset actions; // 你可以理解为action的集合，所有的action都在这里，可以通过名称去获取对应的action。

    protected InputAction m_movement;

    protected virtual void Awake()
    {
        // 一开始时我们就要把 要捕捉的动作 给加进去
        CacheActions();
    }

    // Start is called before the first frame update
    void Start()
    {
        actions.Enable();
    }

    // Update is called once per frame
    protected virtual void Update()
    {
        
    }
    // 操作启用了干什么
    protected void OnEnable()
    {
        actions?.Enable();
    }
    // 操作禁用了干什么
    protected void OnDisable()
    {
        actions?.Disable();
    }
    // 要捕捉哪些操作
    protected virtual void CacheActions()
    {
        m_movement = actions["Movement"];
    }
}
```

---

在 Scripts\Player 下新建脚本 PlayerState\
在 Scripts 下新建文件夹 Entity，并在 Entity 下新建脚本 Entity 和 EntityState

Entity类如下设计：

```csharp
// 这是实体类，玩家也是实体，怪物也是实体，箱子也是实体，所以要抽象
public abstract class Entity : MonoBehaviour
{
    
}
// 搞泛型就是为了方便到时候进行操作
public abstract class Entity<T> : Entity where T : Entity<T>
{
    
}
```

EntityState如下实现：

```csharp
// 实体会有状态，比如人物在原地喘气，人物往前跑等等
public abstract class EntityState<T> where T : Entity<T> // 这里会有报错，不用管，回头再来处理。
{   //实体总是有状态的，那就会有进入状态，退出状态，和在某个状态中
    public UnityEvent onEnter; 
    public UnityEvent onExit;
    
    public float timeSinceEntered { get; protected set; } // 设置一个进入某状态后的时间，比如人物潜水时憋气就需要计时。

    public void Enter(T entity)
    {
        timeSinceEntered = 0f;
        onEnter?.Invoke();  // 当进入状态时，如果有委托事件那就调用
        OnEnter(entity);    // 进入状态
    }

    public void Exit(T entity)
    {
        onExit?.Invoke();
        OnExit(entity);
    }

    public void Step(T entity)  // 在状态中
    {
        OnStep(entity);
        timeSinceEntered += Time.deltaTime; // 状态中就需要每帧加时间了
    }

    protected abstract void OnEnter(T entity);
    protected abstract void OnExit(T entity);
    protected abstract void OnStep(T entity);
}
```

那么UnityEvent这个东西，形象一些讲就是：

我在这里设置了onEnter事件，我在Invoke的时候进行广播，就是拿了个大喇叭喊：我要进入这个状态了！\
然后隔墙有没有耳我不管，我喊完在这边这个函数就完事了。\
那么谁在那听墙角呢？那就是onEnter.AddListener(要做的事)函数干的活了，假如有地方加了这个事件的监听，那他就会在我喊完之后马上去做对应的事情。

随后我们需要写PlayerState，当然它需要继承EntityState，同时它是一个抽象类，先这样写了：

```csharp
public abstract class PlayerState : EntityState<Player> {}
```

此时我们上面设置好的泛型就应当是Player类型，但是没有这个类型，于是在 Scripts\Player下创建Player脚本，这里我建议都在Unity中进行创建。

Player类继承Entity类，泛型为Player类型。

```csharp
public class Player : Entity<Player>
{
    public PlayerEvents playerEvents;
}
```

Player类中有一个事件，是PlayerEvents类型，但我们没有这个类型，遂在 Scripts\Player下创建 PlayerEvents脚本。\
我们要设计这个人物都有什么状态，那么在PlayerEvents脚本中这样写：

```csharp
using UnityEngine.Events;

public class PlayerEvents
{
    public UnityEvent OnJump;
    public UnityEvent OnHurt;
    public UnityEvent OnDie;
    public UnityEvent OnSpin;
    public UnityEvent OnPickUp;
    public UnityEvent OnThrow;
    public UnityEvent OnStompStarted;
    public UnityEvent OnStompFalling;
    public UnityEvent OnStompLanding;
    public UnityEvent OnStompEnding;
    public UnityEvent OnLedgeGrabbed;
    public UnityEvent OnLedgeClimbing;
    public UnityEvent OnAirDive;
    public UnityEvent OnBackflip;
    public UnityEvent OnGlidingStart;
    public UnityEvent OnGlidingStop;
    public UnityEvent OnDashStarted;
    public UnityEvent OnDashEnd;

}
```

我们写了这么一堆事件，现在用不着，别管他们。

此时你的项目里面应该没有编译不通过的东西了。

回到场景中，打开lily预制体，把Player脚本挂上去。\
在Scripts\Player下创建 PlayerStateManager脚本

我们要管理PlayerState，首先要有Player，所以给PlayerStateManager添加了要求Player的特性，如下设计：

```csharp
[RequireComponent(typeof(Player))]
public class PlayerStateManager : EntityStateManager<Player>
{
    
}
```

自然，在Scripts\Player下创建EntityStateManager脚本。

```csharp
public abstract class EntityStateManager : MonoBehaviour
{

}

public abstract class EntityStateManager<T> : EntityStateManager where T : Entity<T>
{
    
}
```
