# 设置状态机

现在我们要开始设计我们的PlayerStateManager了。

当然此时为了避免报错，我们先阅读文档“勘误细节”中的第一点，在Scripts下创建文件夹Tools，并在其下创建对应脚本，这里不在赘述。

打开PlayerStateManager，进行如下设计：

```csharp
[RequireComponent(typeof(Player))]
public class PlayerStateManager : EntityStateManager<Player>
{
    [ClassTypeName(typeof(PlayerState))] 
    public string[] states; // 我们要有一个状态列表，用字符串数组来保存人物状态。

    protected override List<EntityState<Player>> GetStateList() // 所以我们要通过状态名称来获取真正的状态对象。
    {
    }
}
```

此时因为在EntityStateManager中没有进行任何的设计，override会报错，所以我们去基类中添加：

```csharp
public abstract class EntityStateManager<T> : EntityStateManager where T : Entity<T>
{
    protected abstract List<EntityState<T>> GetStateList();
}
```

接上文PlayerStateManager中，我们要实现GetStateList函数，用字符串去拿状态，那就需要在EntityState中进行实现（因为它是PlayerState的父类，而且其他实体也会有获取状态的需求）。

在EntityState最后添加：

```csharp
    // 通过字符串获取一个状态。这里使用了Activator类，它使用了反射。
    public static EntityState<T> CreateFromString(string typeName)
    {
        // 返回通过string拿到的状态
        // 这是在干啥呢，就是说我们的这个物体有很多状态，跑啊跳啊的，我传进来一个状态名字，就要去找它对应的那个对象（类），存在那就是找到了，不存在就报错
        return System.Activator.CreateInstance(System.Type.GetType(typeName)) as EntityState<T>;
    }

    public static List<EntityState<T>> CreateListFromStringArray(string[] array)
    {   // 往数组里面添加状态。
        // 我给你了一个状态名称列表，你得给我创建出来一个真正的状态列表出来，里面的内容都是状态对象
        var list = new List<EntityState<T>>();

        foreach (var typeName in array)
        {
            list.Add(CreateFromString(typeName));
        }

        return list;
    }
```

[Activator.CreateInstance() 的介绍](https://learn.microsoft.com/zh-cn/dotnet/api/system.activator.createinstance?view=net-8.0)

回到PlayerStateManager，这个没写完的函数就正好调用我们刚刚写的函数，通过字符串数组来获取状态数组。

```csharp
protected override List<EntityState<Player>> GetStateList()
{
    return PlayerState.CreateListFromStringArray(states);
}
```

那么我们拿到了状态，但是这些状态都有啥我们没有实现，所以要实现很多状态给我们管理。\
既然现在做的是Player的状态，那就在Scripts\Player下新建文件夹States，并在其下创建我们Player的第一个状态脚本IdlePlayerState

**我自己在做这个项目的时候打错了脚本名，导致后面在反射找这个对象的时候报错，所以类名一定要和到时候输入进去的状态string对应**

既然是Player的State，那就继承PlayerState，然后override实现父类的抽象方法，里面先啥也不填。\
我们知道，OnStep指的是在状态中，那么在状态中我们就要每帧的去更新它，所以这个函数就要有人去调用，谁来调用呢？\
Player有状态，其他的实体也有状态，那么调用OnStep的一定是它们的父类，所以应该是Entity来调用。

所以我们进入Entity，添加如下代码：

```csharp
public abstract class Entity<T> : Entity where T : Entity<T>
{
    // 我们需要当前的状态，才能执行它，所以在物体中要保存它都有什么状态。
    public EntityStateManager<T> states { get; protected set; }

    protected virtual void HandleState()
    {
        // 当在状态中时，执行状态内的东西
        states.Step();
    }

    // 每帧调用执行状态
    protected void Update()
    {
        HandleState();
    }
}
```

那么状态内都有些什么东西呢？我们要实现Step函数，进入EntityStateManager。

```csharp
public abstract class EntityStateManager<T> : EntityStateManager where T : Entity<T>
{
    protected abstract List<EntityState<T>> GetStateList();

    // 当前有什么状态
    public EntityState<T> current { get; protected set; }
    // 谁有状态
    public T entity { get; protected set; }
    // 上面的这个实体我们没有对其进行初始化，那么我们加上初始化的函数
    protected virtual void InitializedEntity()
    {
        // 很容易理解，谁挂了对应的脚本，谁就是什么类型的实体。在课程中第10节才补上了这句话，我想提前补上应该能减少一些疑惑
        this.entity = GetComponent<T>();
    }
    
    // 在状态管理器中，对状态进行调用。
    public virtual void Step()
    {
        if (current != null && Time.timeScale > 0) // 当前有状态且游戏没暂停
        {
            // 让这个实体的当前状态生效
            current.Step(entity);
            // 到这你可能蒙了，但是进入current.Step()看看，它是我们早就实现了的
            // 它被每帧调用，同时在它内部调用了OnStep()函数，而OnStep则是我们在具体的某一个状态中实现的，比如我们已经做出的IdlePlayerState。
        }
    }
}
```

好了，现在我们在Entity中调用在状态中的这个函数已经写好了，那么状态从哪来呢？\
我们回到Entity中，对状态进行初始化。

在类中添加：

```csharp
protected virtual void InitializeStateManager()
{
    // 我们要拿到当前对象的状态，那么在实体状态管理器中有实体的当前状态，所以挂了这个脚本的实体的状态就这样获取
    this.states = GetComponent<EntityStateManager<T>>();
}

protected void Awake()
{
    // 在开始时初始化实体状态
    InitializeStateManager();
}
```

既然我们要获取当前实体的状态，但是在EntityStateManager中，我们没有对当前状态进行初始化，所以现在到EntityStateManager中，对current进行初始化。

在泛型类中添加如下代码

```csharp
// 状态列表
protected List<EntityState<T>> m_list = new List<EntityState<T>>();
// 如果我们想拿到状态列表里面的某个状态，就需要遍历状态列表，那样性能损耗太大了，所以使用一个字典来保存
protected Dictionary<Type, EntityState<T>> m_states = new Dictionary<Type, EntityState<T>>();
// 初始化这个列表和字典
protected virtual void InitializedStates()
{
    // 这是已经声明的抽象方法，直接使用
    m_list = GetStateList();
    // 遍历列表，将状态存入字典，如果有相同状态就不存了。
    foreach (var state in m_list)
    {
        var type = state.GetType();
        if (!m_states.ContainsKey(type))
        {
            m_states.Add(type, state);
        }
    }
    // 当前状态是状态列表中的第一个
    if (m_list.Count > 0)
    {
        current = m_list[0];
    }
}

protected void Start()
{
    // 在开始时初始化实体
    InitializedEntity();
    // 在开始时初始化状态列表
    InitializedStates();
}
```

现在我们回到Unity中，给Lily预制体挂上PlayerStateManager脚本。\
那么我们知道我们之前写的代码是用字符串反射去获取状态，所以在Inspector窗口中，给PlayerStateManager的States参数加一条参数，名称则与我们之前创建的IdlePlayerState类名一样，最好从代码中复制过来，不然会出现空指针异常。
