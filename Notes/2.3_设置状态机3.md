# 设置状态机

上一节结束后我们已经能自上而下的调到确切的某个状态了，你可以在Idle状态中打断点看看一帧里面调用的逻辑顺序，也可以在Entity的Start中打一个断点看看初始化的流程。\
从断点可以看出，我们在Idle状态中拿到的这个Player类型的entity是空的，为啥呢，一层一层的往上去看，在EntityState中Step函数调用了OnStep函数，这里拿到一个泛型的entity，再往上看，到了EntityStateManager中，你会发现我们没有对entity做任何的初始化，直接在Step函数中传入了entity。回头我们再来完善它。

现在应该开始做移动功能了，在idle情况下我要检测移动，那肯定是在OnStep的时候检测，显然我要获取到InputSystem里面的数据了，但是我们在Player中什么也没写，所以打开Player，添加如下代码：

```csharp
public PlayerInputManager inputs { get; protected set; }
```

我们没有必要直接把Input Action给到状态里，因为我们已经提前封装好了Manager类，通过Manager来管理它，所以打开PlayerInputManager，添加如下代码：

```csharp
// 设置一个时间，假如按键的时间短于它，那就不让物体移动，不要让物体太鬼畜
protected float m_movementDirectionUnlockTime;
// 显然我们要知道移动的话要往哪个方向移动，而且这是一个三维游戏，所以要拿到移动方向的三维向量
public virtual Vector3 GetMovementDirection()
{
    if (Time.time < m_movementDirectionUnlockTime)
    {
        return Vector3.zero;
    }
    // 这是InputAction，我们通过读取值的方式，拿到输入的二维向量，注意x是横向的，y是纵向的，对应到游戏的三位空间内，x对应x，y应该对应z，而三维的y则应该是0.
    var value = m_movement.ReadValue<Vector2>();
    // 为了防止有些设备的一些细微输入我们要启用死区（比如手柄摇杆用时间长了有可能偏移位置，导致持续输入一个极小的值，如果把这个值直接关联到移动上，你就能发现人物在慢慢慢慢的往一个方向滑行）
    return GetAxisWithCrossDeadZone(value);
}

public virtual Vector3 GetAxisWithCrossDeadZone(Vector2 axis)
{
    // 获取默认配置文件里面的死区数据，如果想修改这个值，需要在InputSystem模块设置里面新建一个配置文件进行修改，一般我们是不修改。
    var deadZone = InputSystem.settings.defaultDeadzoneMin;
    // 如果输入的值比死区大，那么说明它是有效输入，否则是无效输入
    axis.x = Mathf.Abs(axis.x) > deadZone ? RemapToDeadzone(axis.x, deadZone) : 0;
    axis.y = Mathf.Abs(axis.y) > deadZone ? RemapToDeadzone(axis.y, deadZone) : 0;
    // 虽然我们总说C#中要注意减少new的使用，但是有时候就是无法避免的，这里要返回一个Vector3，不用new那上哪去找一个Vector3来呢？
    return new Vector3(axis.x, 0, axis.y);
}

protected float RemapToDeadzone(float value, float deadzone)
{
    // 由于死区的输入是无效的，所以我们要换算一下有效输入的比例，你可以画个数轴看看，假设死区是0.1，那么在[0, 1]上，有效的输入区间是[0.1, 0.9]，如果我们拿到一个输入是0.6，显然我们需要换算一下它在有效输入区间上的比例是多少，所以让它们都减去死区的值，就能算出来了。
     return (value - (value > 0 ? -deadzone : deadzone)) / (1-deadzone);
}
```

那么移动该怎么去实现呢？\
回到IdlePlayerStates中，我们要在获取到有效输入的时候改变它的状态，毕竟你都检测到位移了，那就要切换成走路的状态。当然我们现在还没有写WalkState，先进行检测。

```csharp
protected override void OnStep(Player entity)
{
    // 调用我们上面写好的函数，获取输入的数值
    var inputDirection = entity.inputs.GetMovementDirection();
    // 我们知道无效输入的时候会返回0向量，那就需要检测一下是否是有效输入
    if (inputDirection.sqrMagnitude > 0 || entity.lateralVelocity.sqrMagnitude > 0)
    {
        entity.states.Change<WalkPlayerState>(); // 如果是有效输入，那就改变状态。我们先假设我们要切换到走路的状态。
    }
}
```

这里插一句我个人的问题：\
inputDirection.sqrMagnitude > 0 和 inputDirection != Vector3.zero 有什么区别？\
风哥的解答是：一个是标量，一个是向量，在数学意义上来说标量能表示出有方向输入进来。

查阅资料后得知：\
零向量的方向应该是“不确定的”，或者说是无法确定的，也就是说给我们一个零向量，没有人能够指出它的方向。 换句话说零向量 (起点与终点重合的向量)是退化的向量，它已经退化到只能确定其大小，而无法确定其方向的一类特殊向量。

那么我们回到我们的业务逻辑中去看，你既然要移动一个角色，那角色的面朝向就要发生变化，所以你需要知道这个角色往哪个方向移动。而与0向量进行比较时，你无法确定0向量的方向。在之后的业务中我们要设置摄像机跟随，无法确定方向，摄像机该怎么跟随呢？跟一个无法确定方向的值进行比较，就像是在取指针指向的垃圾地址一样，结果无法预测，所以这里用一个标量来进行对比，标量大于0，那就一定有输入进来。

**当然这里可能会有一些理解不到位的地方，不用太纠结，接着往后做，当你真正实现人物移动的时候就能理解为什么要用向量了**

这个lateralVelocity没定义，我们到Entity里面定义一下。在泛型类里面添加如下代码：

```csharp
public Vector3 velocity { get; set; }
    
public Vector3 lateralVelocity
{
    get { return new Vector3(velocity.x, 0, velocity.z); }
    set { velocity = new Vector3(value.x, velocity.y, value.z); }
}
// 你能看出来lateralVelocity是velocity的平面版
// 这里提前插一嘴，不改y值是因为我们之后做跳跃和掉落的时候要单独的改，你走路只会在平面上走，当然不涉及y值的改变了
```

课程中讲它是一个速率。\
这个lateralVelocity是物体的侧向速度（平面速度），它的模长越长代表速度越快，它的方向就是速度的朝向。**这是一个向量。**\
主要用来模拟惯性，因为你往前走路的时候，突然拐弯肯定会有原来前进方向的惯性。

那么我们既然要改变实体的状态了，就要实现上面写的Change方法，所以我们去EntityStateManager中实现它。

```csharp
// 我们要记录上一个状态是什么，我们有时候需要做一些功能时会用到。假如实体现在在空中，你要知道它是因为什么在空中，被人打倒空中了还是自己跳起来在空中了，才好执行下一步去切换不同的状态。
public EntityState<T> last { get; protected set; }
// 我们要切换到什么状态，就用这个泛型函数去切换，在它里面加一层保护，避免传null进去报错
public virtual void Change<TState>() where TState : EntityState<T>
{
    var type = typeof(TState);
    if (m_states.ContainsKey(type))
    {
        // 判断状态列表里面有没有这个状态，有就切换，没有就不切换
        Change(m_states[type]);
    }
}
// 真正的切换操作
public virtual void Change(EntityState<T> toState)
{
    // 如果这个状态不是空的（这是避免别的地方直接调用的时候出错）且游戏没有暂停
    if (toState != null && Time.timeScale > 0)
    {
        // 如果当前状态不是空的
        if (current != null)
        {
            // 我们需要让当前状态退出
            current.Exit(entity);
            // 退出的同时记录下当前的状态
            last = current;
        }
        // 改变状态并进入
        current = toState;
        current.Enter(entity);
    }
}
```

到这里，我们就已经做好了切换状态的准备了。现在只需要实现要切换的状态就可以跑通了。