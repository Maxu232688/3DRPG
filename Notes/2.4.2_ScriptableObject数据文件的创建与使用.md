# ScriptableObject数据文件的创建与使用

## 数据文件的创建

### 自定义ScriptableObject数据容器

1. 继承ScriptableObject类
2. 在该类中声明成员（变量、**方法**等）
   可以声明任何类型的成员变量，如果希望在Inspector窗口中能编辑它，那就得是public的

注意：声明后点击该脚本可以在Inspector窗口中看到变化，现在改它们就是设置默认数据，这些关联信息都是通过脚本文件对应的Unity配置文件meta进行记录的，目前只是一个数据容器模板，要真正使用还需要根据它的信息去创建对应的数据资源文件


### 根据自定义的数据容器创建数据文件

注意:
该创建功能,其实就是根据自定义数据容器类创建了一个配置文件\
该文件中记录了对应的数据容器类信息，以及其中变量关联的信息\
之后我们在使用它时，本质上也是通过反射创建对象进行使用

具体的方法有两种:

1. 为类添加CreateAssetMenu通过菜单创建资源特性

    ```cs
    // 要注意的是这个特性必须在继承ScriptableObject的类前写，不写括号里面的内容也是可以的，写了就是在菜单上面自定义了一下它的名字，order就是在菜单上的上下顺序
        [CreateAssetMenu(filellme = "PlayerStats" , menuName ="CreatePlayerStats" ,order = 0 /*在Asset/Create菜单中的位置(多个ScriptableObjects存在时使用的)*/)]
        public class PlayerStats : EntityStats<PlayerStats>
        {
            // .....
        }
    ```

    然后在unity里面在Project窗口中点右键就可以看到页签了

2. 利用ScriptableObject的静态方法创建数据对象

    ```cs
        public class ScriptableObjectTool
        {
            // 这样在unity的编辑器窗口上方工具栏内就多了一个选项，点击执行的就是这个函数
            [MenuItem("ScriptableObject/CreateMyData")]
            public static void CreateMyData()
            {
                // 创建数据文件的代码
                PlayerStats playerStats = ScriptableObject.CreateInstance<PlayerStats>();
                // 通过编辑器Api，根据数据创建一个数据资源文件
                AssetDatabase.CreateAsset(playerStats, "Assets/Resources/MyDataTest.asset")
                // 你可以看看给的资源里面的Stats文件夹下文件的后缀是什么

                // 保存创建的资源
                AssetDatabase.SaveAssets();
                // 刷新界面
                AssetDatabase.Refresh();
            }
        }
    ```

### 好处的体现

1. 更方便配置数据，直接在Inspector中配置
2. 项目之间复用，可以拷贝继承ScriptableObject的脚本到任何工程中

## 数据文件的使用

### 如何使用

1. 通过Inspector中的public变量进行关联
   1-1. 创建一个数据文件\
   1-2. 在继承MonoBehaviour类中声明数据容器类型的成员，然后在Inspector窗口中关联

    ```cs
    // 就像是我们项目中的这个类
    public abstract class EntityStatsManager<T> : MonoBehaviour where T : EntityStats<T>
    {
        // 不用在意这个数组，如果有很多属性，才会用得到数组，现在我们只有一个属性，也就是说数组里面只有一个数据文件
        public T[] stats;
        public T current { get; protected set; }
    }
    ```

    在Inspector窗口中，给StatsManager拖上的东西一定是生成出的这个数据文件，而不是我们写的Stats类。
    至于怎么调用，你应该在项目中有了深刻的印象。

2. 通过资源加载的信息关联

    ```cs
    // 第二种方式，举个例子
    public class PlayerStatsManager : EntityStatsManager<PlayerStats>
    {
        public PlayerStats stats；

        void Start()
        {
            stats = Resources.Load<PlayerStats>("文件路径");
        }
    }
    ```

   要注意的是 Resources，AssetsBundle，Addressables都支持加载继承ScriptableObject的数据文件，上面代码里面用了Resources，具体要看你的文件放到哪里了，放到哪就用谁的方法。

如果多个对象关联同一个数据容器文件，它们共享的是一个对象
因为是引用对象，所以在其中任何地方修改后，其他地方也会发生变化

### 生命周期函数

ScriptableObject和MonoBehavior很类似，也有生命周期函数。\
了解就行，ScriptableObject的生命周期很少。

```cs
public class PlayerStats : EntityStats<PlayerStats>
{
    private void Awake()
    {
        Debug.Log("数据文件创建时会调用");
    }

    private void OnEnable()
    {
        // 创建或者加载对象时调用，比如上面的Load函数时，就会调用
    }

    private void OnDisable()
    {
        // 对象销毁时，即将重新加载脚本程序集时 调用
    }

    private void OnDestroy()
    {
        // 对象将被销毁时调用
    }

    private void OnValidate()
    {
        // 你在Inspector窗口里面改文件的数据时调用
    }
}
```

### 好处的体现

1. 编辑器中的数据持久化
    通过代码修改数据对象中内容，会影响数据文件相当于达到了编辑器中数据持久化的目的(该数据持久化只是在编辑模式下的持久，发布运行时并不会保存数据)
    什么意思，就是说如果你在unity里面运行，然后改了PlayerStats里面的数据，结束运行后你会发现数据的修改被保存下来了（比如踩下一个开关会修改是否能够捡起箱子，刚开始是true，踩了开关之后改成false，lily不能拿箱子了，结束运行后这个false会被保留下来）；但是发布后不具备这个特点，发布后它虽然可以在运行时被改变，但是不会保存，下次运行的时候它还是设置好的默认值。

2. 复用数据
    如果多个对象关联同一个数据文件，相当于他们复用了一组数据，内存上更加节约空间

其实创建出来的数据资源文件，你可以把它理解成一种记录数据的资源它的使用方式，和我们以前使用unity当中的其它资源规则是一样的。比如：预设体、音频文件、视频文件、动画控制器文件、材质球等等。\
只不过通过继承Scriptableobject类生成的数据资源文件，它主要是和数据相关的

可以理解为数据预制体