# ScriptableObject非持久数据

## 非持久化数据是什么

指的是不管在编辑器模式还是在发布后都不会持久化的数据，我们可以根据自己的需求随时创建对应数据对象进行使用，就好像直接new一个数据结构类对象

## 如何生成非持久化数据

利用ScriptableObject中的静态方法 `CreateInstance<>()`，该方法可以在运行时创建出指定继承ScriptableObject的对象\
该对象只存在于内存当中，可以被GC\
调用一次就创建一次

```cs
// 我们知道PlayerStats是继承了ScriptableObject的，所以这里拿它举例子

public class Test
{
    public PlayerStats = stats;

    void Start()
    {
        // 通过这种方式创建的数据对象，它里面的默认值不会受到脚本中设置的影响
        stats = ScriptableObject.CreateInstance<PlayerStats>();
        // 怎么理解这个不受脚本中设置影响，就是说如果我们在Inspector窗口中去改了PlayerStats 这个 C#脚本 的默认值，通过这种方式去创建了之后不会应用到代码里面，而采用的默认值是代码里面声明的默认值，就比如我们在Lily项目中做的。
    }
}
```

## 非持久化数据存在的意义

只是希望在运行时能有一组唯一的数据可以使用，但是这个数据又不太希望保存为数据资源文件浪费硬盘空间，那么ScriptableObject的非持久化数据就有了存在的意义\
它的特点是只在运行时使用，在编辑器模式下也不会保存在本地

## 如何实现真正的持久化

我们知道，ScriptableObject的持久化只是在编辑模式下发生作用，发布后就不存在了。那么如何实现真正的持久化呢？

就是通过数据持久化将数据存储到硬盘，不会的看后文数据持久化的扩展知识

### 利用Json存储

```cs
public class Test
{
    public PlayerStats stats;

    void Start()
    {
        string str = JsonUtility.ToJson(stats);
        File.WriteAllText("路径", str);
    }
}
```

### 利用Json读取

```cs
public class Test
{
    public PlayerStats stats;

    void Start()
    {
        string str = File.ReadAllText("文件路径");
        // 覆盖到这个stats对象上，不是新建对象，直接用FromJson是新建对象了
        JsonUtility.FormJsonOverwrite(str, stats);
    }
}
```

对于ScriptableObject的数据：由于它在游戏发布运行过程中无法被持久化，我们可以利用 PlayerPrefs、XML、Json、2进制等等方式让其可以达到被真正持久化的目的。\
但是有什么用呢？你不如真写个存档得了。