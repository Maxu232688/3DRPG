# ScriptableObject的应用

## 为什么要用ScriptableObject来做配置文件

1. 配置文件的数据在游戏发布之前定规则
2. 配置文件的数据在游戏运行时只会读出来使用，不会改变内容
3. 在Unity的Inspector窗口进行配置更加的方便

就是说我们只需要在unity里面去改，改完了还要保存下来，就跟改预制体一样，发布出去了就让它只读。

如果没有ScriptableObject，你要做一个PlayerStats，全写到代码里面的话，游戏一更新要平衡技能数据了，你是不是得重新打包，而如果是配置文件，那就只需要换掉配置文件就行了。那没有ScriptableObject的时候你想做个这样的功能，是不是得用写存档的办法去写个json，xml还是二进制文件。

所以，有了ScriptableObject，又可以轻松在Inspector里面编辑，又能存下来，读的时候还不用解析文件，为啥不用呢？

你可能想问，这不还是要弄个类写到代码里吗？我们在Lily项目里面把数据全写道代码里面了，有什么区别？

那我再举个例子，如果我们的项目里不止有Lily一个角色，我们还有很多很多角色，每个角色的属性都不一样，比如Mark的跑的比Lily快，但它跳的比lily低，爬杆也没lily快，那是不是需要很多不同的PlayerStats？\
如果你全写到代码里面，你又得继承一大堆什么LilyPlayerStats，MarkPlayerStats，你的代码就爆炸了。\
**我们写的PlayerStats是一个模板，把数据直接写在代码里面只不过是设置了默认值，我们通过PlayerStats这个模板可以创建很多数据文件，把这些不同的数据文件挂给不同的角色，才是我们真正的目的。**

## 复用数据

**用预制体对象可能的内存浪费现象**

假如有一堆同样的子弹，那它的初始飞行速度，重量，乱七八糟的数据肯定都是一样的。\
全部都在一个类里面实现，然后把这个类挂到子弹上面去，然后在游戏进行的时候，你一把游戏可能打出去成千上万个子弹，所以子弹会被做成预制体。\
这把游戏你在那里突突突突突，那生成了很多很多子弹对象，每个子弹对象上面挂的脚本都是独立生成的，所以这些属性数据重复的生成了很多次，所以就浪费了内存。

既然子弹的这些乱七八糟的数据都是一样的而且不会改变，那肯定想让他们用同一个数据，不要反复的定义。

而像是子弹的坐标，子弹碰撞盒碰到的物体，子弹当前的飞行速度这类数据，那每个子弹都不一样，这没办法，是必须单独生成的。

**用ScriptableObject对象节约内存**

那么使用ScriptableObject创建的数据文件，让所有的子弹都挂上这个数据文件，去取里面的数据，你就是创建一万个子弹对象，也共享同一个数据文件。

但是如果代码里面修改了数据文件里面的数据，所有关联的对象都会受到影响。

## 数据带来的多态行为

某些行为的变化是因为数据的不同带来的，我们可以利用面向对象的特性和原则，以及设计模式相关知识点结合ScriptableObject做出更加方便的功能

比如随机音效，物品拾取，AI等等等

随机音效（里氏替换原则和依赖倒转原则）：播放音乐时，可能会随机播放多个音效当中的一种\
物品拾取（里氏替换原则和依赖倒转原则）：比如拾取一个物品，物品给玩家带来不同的效果\
AI：不同数据带来的不同行为模式

为了方便我们使用，我们可以利用ScriptableObject的可配置性来制作这些功能

你可以看看我们工程里面的PlayerAudio这个文件，这就是把数据写到代码里面了，如果要修改脚步声，那只能重新发布。

这里举个例子：

```cs
public abstract class AudioPlayBase : ScriptableObject
{
    public abstract void Play(AudioSource audio);
}
```

```cs
[CreateAssetMenu()]
public class RandomPlayAudio : AudioPlayBase
{
    public List<AudioClip>[] clips;

    public override void Play(AudioSource audio)
    {
        if (clips != null && clips.Length > 0)
        {
            var index = UnityEngine.Random.Range(0, clips.Length);

            if (clips[index])
            {
                audio.PlayOneShot(clip)
            }
        }
    }
}
```

通过这样的代码，创建出来RandomPlayAudio配置数据文件，然后给配置数据文件里面的clips数组关联上音效文件，在代码里面去使用这个配置文件，就可以了。

那么代码里面怎么用呢？对项目中的PlayerAudio进行优化可以用这样的思路，我这里拿了一部分项目里的代码，结合上面写的类，去理解一下该如何使用

```cs
public class PlayerAudio : MonoBehaviour
{
    protected AudioSource m_audio;
    public AudioPlayBase audioPlay;

    protected virtual void InitializeAudio()
    {
        if (!TryGetComponent(out m_audio))
        {
            m_audio = gameObject.AddComponent<AudioSource>();
        }
    }

    protected void Start()
    {
        ...
        // 在Lily预制体中给这个脚本挂上对应的数据配置文件，就能调用对应的子类Play函数播放不同的音效
        audioPlay.Play(m_audio);
        // 你可以把这个配置数据文件想象成 中间商，每个中间商供的货不一样，我们想换货就可以直接换中间商了
    }
}
```

多态，能想明白吧，调一个父类play函数，可以调到子类play，就是多态行为了。那子类就可以多种多样了。

同样的，你如果想去实现捡道具加血，加攻击等操作，也可以通过实现一个基类，子类里面实现各种特效，然后生成配置文件，挂载配置文件上去，玩家在捡物体的时候调用父类的效果函数，就能实现不同的效果。\
有没有感觉这个操作和各种物品里面实现了不一样的功能，监听了player的捡起事件有点像呢？

## 单例模式化的获取数据

### 为什么要单例模式化的获取数据

对于只用不变并且要复用的数据，比如配置文件中的数据，我们往往需要在很多地方获取他们\
如果我们直接通过在脚本中 public关联 或者 动态加载，在多处使用时，会存在很多重复代码，效率较低\
如果我们将此类数据通过单例模式化的去获取，可以提升效率，减少代码量

就是说同样的一份数据，如果有一堆脚本要调取它的数据，那最好通过一个单例类去调，单例类直接拿到这个数据，用别的类去调单例里面的数据就行了。

### 如何单例模式化的获取数据

我们可以实现一个ScriptableObject数据单例模式基类让我们只需要让子类继承该基类就可以直接获取到数据，而不再需要去通过 public关联 和 资源动态加载。

实现单例类

```csharp
public class SingleScriptableObject<T> : ScriptableObject where T : ScriptableObject
{
    private static T m_instance;

    public static T instance
    {
        get
        {
            if (m_instance == null)
            {
                m_instance = Resources.Load<T>("数据文件路径");

                if (m_instance == null)
                {
                    m_instance = CreateInstance<T>();
                }
            }

            return m_instance;
        }
    }
}
```

现在如果看看子弹的数据该怎么去实现

```csharp
[CreateAssetMenu()]
public class BulletStats : SingleScriptableObject<BulletStats>
{
    public float initSpeed;
    public float weight;
    // 等等数据
}
```

用到子弹这些数据的地方就可以这样调用

```cs
void Start()
{
    var iSpeed = BulletStats.instance.initSpeed;
}
```

好的，到此ScriptableObject的介绍就结束了，有没有发现我们的Lily工程中还有很多能够优化的点呢？当然不要为了用它而用，要因地制宜，不要把简单的东西做复杂了。