# 设置状态机

上节遗留了WalkPlayerState没有创建，现在接着去做它。\
在Scripts\States下创建WalkPlayerState脚本，继承PlayerState并且override里面的函数。

我们知道在第三人称游戏里，人物移动时相机也要进行跟随，我们要对相机进行处理，一般情况下主相机就是跟随人物移动的。\
打开PlayerInputManager，添加如下代码：

```csharp
// 跟随人物的相机
protected Camera m_camera;

void Start()
{
    // 别忘了在Start里面获取它，我们就用主相机
    m_camera = Camera.main;
    actions.Enable();
}

// 既然角色要移动，我们就要算出来相机要旋转的角度，设置相机旋转后的方向
public virtual Vector3 GetMovementCameraDirection()
{
    // 首先我们获取人物移动的方向
    var direction = GetMovementDirection();
    // 如果输入是有效输入
    if (direction.sqrMagnitude > 0)
    {
        // 我们拿到当前的rotation是一个 绕y轴正方向旋转m_camera.transform.eulerAngles.y度 的四元数
        var rotation = Quaternion.AngleAxis(m_camera.transform.eulerAngles.y, Vector3.up);
        // 我们知道，我们输入进来的direction是键盘wasd或者手柄摇杆给的一个值，它放在Vector3中是以 (x, 0, y) 的方式呈现的。
        // 那么既然要改变方向，我们肯定不能直接把键盘输入的值放进去改，而是键盘按了键，要计算出来一个改变后的方向
        // 四元数和向量相乘表示这个向量按照这个四元数进行旋转之后得到的新的向量。也就是说输入进来的这个向量要 绕y轴正方向旋转m_camera.transform.eulerAngles.y的角度
        direction = rotation * direction;
        // 我们只需要得到旋转后向量的方向就行了，因为人物的速度我们是要在人物属性中规定的，这里只需要方向，不需要长度。
        direction = direction.normalized;
    }

    return direction;
}
```

`Quaternion.AngleAxis(float angle,Vecotr3 axis)`函数返回的是一个四元数，创建一个围绕 axis 旋转 angle 度的旋转。

回到WalkPlayerState中

```csharp
    protected override void OnStep(Player entity)
    {
        // 移动的话就要拿到他相机的方向了，要做一些处理
        var inputDirection = entity.inputs.GetMovementCameraDirection();
        // 同样的，如果是有效输入
        if (inputDirection.sqrMagnitude > 0)
        {
            // 这个点积的意义就是侧向速度在输入方向上的投影长度，可以理解为在目前输入方向上的速度值，即在inputDirection方向上的速度到底是多少。
            var dot = Vector3.Dot(inputDirection, entity.lateralVelocity);
            // 判断在输入方向上的速度有没有达到这个移动的阈值，如果没有达到这个阈值，那就不需要移动。
            //（其实你看英文函数命名也能知道，Accelerate是加速度，也就是说我们没有在inputDirection方向上达到移动阈值的速度，那就不给他这个方向上的加速度）
            if (dot >= entity.stats.current.brakeThreshold)
            {
                // 把方向传进去，给这个方向加一个加速度。没写这个函数，所以要去Player里面实现它了。
                entity.Accelerate(inputDirection);
            }
        }
    }
```

`Vector3.Dot`：两个向量的点积。点积是一个浮点值，它等于 将两个向量的大小相乘，然后乘以向量之间角度的余弦值。\
对于 normalized 向量，如果它们指向完全相同的方向，Dot 返回 1； 如果它们指向完全相反的方向，返回 -1；如果向量彼此垂直，则 Dot 返回 0。

**lateralVelocity是实体的侧向速度，它是一个有方向的速度，它的模长就是速度的大小。由于我们计算了点积，这个点积的意义就是侧向速度在输入方向上的投影长度，可以理解为在目前输入方向上的速度值。**

那么我们就在Player中加上这个函数

```csharp
public virtual void Accelerate(Vector3 direction)
{
    // 先不管它怎么实现，总之就是要朝着传入的方向移动了
}
```

---

上文中，我们要让输入方向的速度和移动速度阈值进行对比，那这些东西应该是实体的属性，我们需要一套实体的属性管理类，于是我们要创建很多脚本了。

不过在此之前，我们现在Player中声明一下这个属性。

```csharp
// 这就是实体的属性，只不过我们特化了Player，以后怪物是不是也会有这个属性呢？
public PlayerStatsManager stats { get; protected set; }
// 在下一节中我们要围绕它来实现这些stats里面的内容，毕竟我们要用属性，就得给他设计很多属性。
```

这个时候发挥你的想象力，既然我们要一个PlayerStatsManager，那是不是就要有PlayerStats给它管理，那么Player是Entity的一种，所以Entity也要有Stats，也要有StatsManager。

我们在Scripts\Entity下创建脚本 EntityStatsManager

```csharp
public abstract class EntityStatsManager<T> : MonoBehaviour where T : EntityStats<T>
{
}
```

在Scripts\Entity下创建脚本 EntityStats

**这里为啥继承ScriptableObject？**

```csharp
public class EntityStats<T> : ScriptableObject where T : ScriptableObject
{
}
```

在Scripts\Player下创建脚本 PlayerStatsManager

```csharp
public class PlayerStatsManager : EntityStatsManager<PlayerStats>
{
}
```

在Scripts\Player下创建脚本 PlayerStats

```csharp
public class PlayerStats : EntityStats<PlayerStats>
{
}
```

---

这里遇到了一个一带而过的内容：ScriptableObject，这东西最好能了解一下。我在后面的文档里面贴出来了，也可以先跳过接着做项目，回头再来看这部分。\
~~因为我也是后来才补上的~~