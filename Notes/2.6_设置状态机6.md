# 设置状态机

我们终于要实现人物的移动了！让我们的状态机运行起来！

---

首先记得调整摄像机的位置，因为现在还没有和人物绑定，所以调整到可以看到人物的地方就行。

我们已经写好了人物的属性，那就要把它用起来，打开lily预制体，把PlayerStatsManager挂上去

因为要走路，所以在PlayerStateManager脚本中，还需要添加WalkPlayerState的状态，注意类名不要打错了。

打开Resource\Stats目录，我们要使用RegularPlayerStats，这是前面说过的ScriptableObject相关的东西。\
点击RegularPlayerStats，在右侧Inspector窗口上加入PlayerStats脚本。\
目前你就能看见我们之前在代码中暴露给外面的一些属性了。

回到Lily预制体中，将PlayerStatsManager的Stats数组长度设置为1，然后挂载RegularPlayerStats在上面。

打开Player脚本，你会发现我们并没有对inputs和stats进行初始化，所以现在来初始化它们。

```csharp
public PlayerInputManager inputs { get; protected set; }

public PlayerStatsManager stats { get; protected set; }

protected virtual void InitializedInputs()
{
    inputs = GetComponent<PlayerInputManager>();
}

protected virtual void InitializedStats()
{
    stats = GetComponent<PlayerStatsManager>();
}

// 这里override会报错，是因为它的父类里面有Awake方法，但我们没有给它添加virtual的关键字。所以去添加上就好了。
protected override void Awake()
{
    base.Awake();
    InitializedInputs();
    InitializedStats();
}
```

还记得我们花了好大功夫去研究的Accelerate函数吗？\
其实它应该写在基类里面，因为不仅仅是玩家要移动转向，怪物也要移动转向，为了让大家都能用，所以我们把它剪切到Entity类里面。

虽然废了九牛二虎之力去算这些数据，但是我们没有对场景中的坐标信息进行更改，那么要让人物动起来，还需要再加上这部分的内容。

我们在Entity里加上如下内容

```csharp
protected void Update()
{
    HandleState();
    HandleController();
}

protected virtual void HandleController()
{
    // 把velocity应用到座标上去
    transform.position += velocity * Time.deltaTime;
}
```

别忘了，我们没有在PlayerInputActions中加入任何关于“Run”的配置，这样是会报错的。\
所以打开配置文件，在中间栏加入Run的配置。

**你用了给的配置文件就不会报错，之后我就不一一细说了**

现在进入场景运行，你应该能看见按wasd人物可以移动了。当然现在按反方向是没法移动的，因为我们没有做。\
回到那个加速度函数中你可以看到，如果我们传入相反方向的direction，算出的speed将会是0，所以不会有任何的移动。

---

到此，我们的状态机终于是做的差不多了。