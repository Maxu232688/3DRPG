# 人物重力

问题：为什么这个时候不加刚体呢？\
答案：CharacterController里面有刚体

如果你已经按照14节的内容做了，那就把BrakePlayerState中14节的内容先注释了，我们暂时用不到这些内容。\
如果你没做14节的内容，也不影响阅读之后的文档。75节才会用到14节的内容。\
我会对不太明白的流程进行一些优化。

---

当人物要受到重力的影响，不能悬空对吧。所以我们在IdlePlayerStates中加上：

```csharp
protected override void OnStep(Player entity)
{
    // 加上重力函数
    entity.Gravity();
    // 之前写的内容就不展示了，用 ... 代替了
    ...
}
```

同样的，在WalkPlayerState中也加上

```csharp
protected override void OnStep(Player entity)
{
    // 加上重力函数
    entity.Gravity();
    ...
}
```

人物既然要受到重力，那就要实现这个重力函数，打开Player

```csharp
public virtual void Gravity()
{
    // 当人物不在地面上 且 垂直速度 大于 -重力最高速度时
    // 因为你往下掉的时候，是向y轴负方向移动的，所以实际上是这个下落速度还没达到最高速度的时候
    if (!isGrounded && verticalVelocity.y > -stats.current.gravityTopSpeed)
    {
        // 获取到垂直速度
        var speed = verticalVelocity.y;
        // 如果当前垂直速度是大于0的，也就是说还在向上运动的时候，我们给他施加重力，否则施加下落的力。
        // 这里看起来有点反常识，但实际上我们只是在对他的速度进行变化，向上的时候和下落的时候是不一样的。
        var force = verticalVelocity.y > 0 ? stats.current.gravity : stats.current.fallGravity;
        // 让 speed 减去施加的力*每帧的时间，实际上就是减小速度。
        speed -= force * gravityMultiplier * Time.deltaTime;
        // 限制一下速度，不能高于下落的最高速度。
        speed = Mathf.Max(speed, -stats.current.gravityTopSpeed);
        // 把速度值应用
        verticalVelocity = new Vector3(0, speed, 0);
    }
}
```

这里我们用到了几个没有定义的stats，我们打开PlayerStats进行添加

```csharp
[Header("General Stats")] 
public float rotationSpeed = 970f;
public float friction = 16f;
// 加上这些参数
public float gravity = 38f;
public float gravityTopSpeed = 50f;
public float fallGravity = 65f;
```

同时你发现gravity也有倍乘系数，那就再Entity里面添加它

```csharp
// 如果你做了14节内容，这里就是添加过的，没做就加上
public float gravityMultiplier { get; set; } = 1f;
```

随后我们来加入人物的掉落状态，因为你有了竖直方向的力，得施加上去人物才能掉落。

在Scripts\Player\States下创建脚本FallPlayerState


```csharp
public class FallPlayerState : PlayerState
{
    protected override void OnEnter(Player entity)
    {
    }

    protected override void OnExit(Player entity)
    {
    }

    protected override void OnStep(Player entity)
    {
        // 人在下落的时候肯定要受重力影响
        entity.Gravity();
        // 让角色朝向改变到侧向速度的方向
        entity.FaceDirectionSmooth(entity.lateralVelocity);
        // 如果人物在地面上，那就不需要掉落，让他变成idle
        if (entity.isGrounded)
        {
            entity.states.Change<IdlePlayerStates>();
        }
        
    }
}
```

那既然有了这个状态，什么时候切换到它呢？\
我们在Idle，Walk，Brake这几个状态中的OnStep函数中都加入一个函数

```csharp
// 要注意的是它要写在Gravity函数的下面，其他内容的上面
entity.Fall();
```

我们打开Player，实现这个Fall函数

```csharp
public virtual void Fall()
{
    if (!isGrounded)
    {
        // 它只管切换状态，具体怎么掉落我们再到Fall状态里面设计
        states.Change<FallPlayerState>();
    }
}
```

打开Entity，修改Update函数，并加入掉落相关的功能，先看Update函数

```csharp
// 这里课程中把所有的参数相关都挪到了Entity类中，但实际上在不在泛型类里面都一样的，所以我就不在这里粘贴太多代码了，只把发生变化的东西写出来。

// 角色的controller的高度，就是CharacterController创建出来的那个胶囊体的高度。
public float height => controller.height;
// 胶囊体两端半球的半径
public float radius => controller.radius;
// 胶囊体的中心点坐标，注意这里是相对坐标，一般情况下是(0,0,0)
public Vector3 center => controller.center;
// 获取人物坐标再加上胶囊体中心的坐标
public Vector3 position => transform.position + center;

// 与地面的偏移量，因为是常量，就要设置一个readonly防止别人改动它
protected readonly float m_groundOffset = 0.1f;
// 上一次在地面上是什么时候
public float lastGroundTime { get; protected set; }
// controller.stepOffset：台阶偏移量，以米为单位，高度低于该值的台阶不会阻挡前进
// setPosition 是 角色当前位置坐标减去 y 坐标中的 height * 0.5f - controller.stepOffset 的值。
// 你可以想象为：这个stepPosition在角色的position，然后它的y坐标减去了自身高度的一半，由于position实际上在角色的中心，所以现在stepPosition在角色脚下。然后它又减去了stepOffset，所以它就是在角色下方stepoffset的距离的位置。
public Vector3 stepPosition => position - transform.up * (height * 0.5f - controller.stepOffset);
// 记录一下射线发射到脚下碰撞到的物体
public RaycastHit groundHit;


// 这里是我们做射线检测的函数，传入的参数是：
// 检测的方向，检测的距离，返回碰到的物体，检测所在的物理层级（默认是Default），检测该射线是否命中触发器（默认忽略）
public virtual bool SphereCast(Vector3 direction, float distance, out RaycastHit hit,
    int layer = Physics.DefaultRaycastLayers,
    QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.Ignore)
{
    // 算出我们要发射的射线长度，这里为啥要减去半径呢，是因为球形射线检测的时候发射的是一个带一个半球的圆柱体，具体可以看代码块后附上的链接，实际上检测的就是人物脚下offset距离碰到地面没有。
    var castDistance = Mathf.Abs(distance - radius); 
    // 调用真正的球体射线检测函数，这里用到了新的变量position和radius，我们在上面声明它
    return Physics.SphereCast(position, radius, direction, out hit, castDistance, layer, queryTriggerInteraction);
    // 到此我们就得到了脚下有没有东西的结果了。
}

// 看函数名就知道了，我们有时候发射的射线碰到的坐标有可能在台阶下面，但是人物实际上在台阶上面
public virtual bool IsPointUnderStep(Vector3 point)
{
    // 这里stepPosition没有声明，在上面声明
    // 返回值：台阶偏移点如果在射线碰撞坐标的上方，就是true
    return stepPosition.y > point.y;
}


// 从这里开始看，Update上面的都是工具和属性，下面的都是逻辑

// 加上virtual关键字，以便其他子类能够override调用
protected virtual void Update()
{
    // 当角色控制器启用时才去检测这些东西
    if (controller.enabled)
    {
        HandleState();
        HandleController();
        // 检测是否在地面上
        HandleGround();
    }
}

protected virtual void HandleGround()
{
    // 首先我们要计算角色离地面的高度，这个高度就是角色的controller的高度 * 0.5 再加上人物和地面的偏移量。这个偏移量是个常量。所以我们在上面声明这两个参数
    var distance = (height * 0.5f) + m_groundOffset;
    // 我们需要检测现在角色脚下的情况，但是我们还需要拿到射线都碰到了什么以便以后使用，所以需要再封装一层函数。
    // 这里的判断是如果脚下有东西 且 垂直速度小于等于0，即有可能没有垂直速度，有可能正在下落
    if (SphereCast(Vector3.down, distance, out var hit) && verticalVelocity.y <= 0)
    {
        // 如果角色不在地面上
        if (!isGrounded)
        {
            // 不在地面上就该下落，这里要检测是否落地
            if (EvaluateLanding(hit))
            {
                // 落地了就进入落地函数
                EnterGround(hit);
            }
            else
            {
                HandleHighLedge(hit);
            }
        }
    }
    else
    {
        // 如果脚下没东西 或者 垂直速度大于0（人物在上升），执行离开地面的函数
        ExitGround();
    }
}

// 检测是否落地
protected virtual bool EvaluateLanding(RaycastHit hit)
{
    // hit.point 是 世界空间中射线命中碰撞体的撞击点。
    // 工具函数，内容在上面。
    // 判断： 射线碰撞点是否在台阶偏移点下方 && 射线碰撞点的法线向量于y轴正方向的夹角是否小于角色控制器的坡度限制
    return IsPointUnderStep(hit.point) && Vector3.Angle(hit.normal, Vector3.up) < controller.slopeLimit;
}

protected virtual void HandleHighLedge(RaycastHit hit)
{
    // 空着先不写
}

protected virtual void EnterGround(RaycastHit hit)
{
    // 不在地面上才能落地
    if (!isGrounded)
    {
        // 记录碰撞到的东西，在上面声明
        groundHit = hit;
        // 更改落地状态
        isGrounded = true;
        // 发送落地事件
        entityEvents.OnGroundEnter?.Invoke();
    }
}

protected virtual void ExitGround()
{
    // 如果在地面上，我们要让它离开地面
    if (isGrounded)
    {
        // 所以设成false
        isGrounded = false;
        // 角色飞到了空中，那它肯定不会有父对象，直接设置为空
        transform.parent = null;
        // 记录一下上次在地面上的时间是什么时候，这个没有声明，我们在上面声明
        lastGroundTime = Time.time;
        // 垂直速度应该大于0，小于0就取0
        // 这里又是为啥呢？因为你要离开地面了，垂直速度还是向下的，你怎么离开，只能向上或者为0时才有可能离开地面，向下时要么是在下落要么落地了。
        verticalVelocity = Vector3.Max(verticalVelocity, Vector3.zero);
        // 调用实体事件，实体离开地面的时候发送事件，这里我们没有定义，请看下个代码块。
        entityEvents.OnGroundExit?.Invoke();
    }
}

```

[Physics.SphereCast()函数的参数都代表什么](https://blog.csdn.net/qwsx789/article/details/51028249)

[Physics.SphereCast()函数的图形化理解](https://blog.csdn.net/weixin_45547407/article/details/129495110)

还记得我们之前创建的PlayerEvents吗，虽然里面的东西我们都没有用到，但是这里的EntityEvents是一样的，我们在Scripts\Entity下创建脚本EntityEvents。

**这里课程没有说，但是我觉得PlayerEvents应该继承EntityEvents啊。不是很确定，到后面如果改了就在这里补上。**

```csharp
// 一定要序列化
[Serializable]
public class EntityEvents
{
    public UnityEvent OnGroundEnter;
    public UnityEvent OnGroundExit;
    public UnityEvent OnRailEnter;
    public UnityEvent OnRailExit;
}
```

不要忘记在Lily预制体中加入掉落的状态。

此时我们运行场景，你可以在编辑窗口中拖拽lily的y坐标，就能看出来已经有掉落的动画了。