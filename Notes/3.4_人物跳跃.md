# 人物跳跃

旋转，跳跃，我闭着眼

---

有重力了就得让他跳起来，在此之前我们要在PlayerInputActions配置文件里面加上跳跃的按键。在中间栏新建动作命名为Jump，然后选择Button模式，在其下的按键绑定中绑定空格键。

打开Player，我们来写Jump函数

```csharp
public virtual void Jump()
{
    // 能不能二级跳（多级跳），首先判断跳跃计数器是不是大于0，并且 跳跃次数要小于设定的最多跳跃次数
    var canMultiJump = (jumpCounter > 0) && (jumpCounter < stats.current.multiJumps);
    // 能不能土狼时间，土狼时间是指在人物离开平台后还能进行操控的那段时间。
    // 如果没有进行过跳跃 并且 当前的时间 小于 上次在地面上的时间（如果在地面上这个值会一直更新） + 土狼时间
    var canCoyoteJump = (jumpCounter == 0) && (Time.time < lastGroundTime + stats.current.coyoteJumpThreshold);
    // 在地面上时 或 能多级跳 或 在土狼时间，那就能跳起来
    if (isGrounded || canMultiJump || canCoyoteJump)
    {
        // 还记得我们如何用代码检测InputAction吗
        if (inputs.GetJumpDown())
        {
            // 按下跳跃键就跳
            Jump(stats.current.maxJumpHeight);
        }
    } 

    // 如果 松开跳跃键 且 跳跃次数大于0 且 垂直速度大于设定最小跳跃高度
    if (inputs.GetJumpUp() && (jumpCounter > 0) && verticalVelocity.y > stats.current.minJumpHeight)
    {
        // 重置垂直速度
        verticalVelocity = Vector3.up * stats.current.minJumpHeight;
    }

    // 这里用到了好几个没声明的属性，我们下面声明它们
}

// 该怎么让人物跳呢？
public virtual void Jump(float height)
{
    // 首先让跳跃次数+1
    jumpCounter++;
    // 给人物向上的垂直速度
    verticalVelocity = Vector3.up * height;
    // 切换到掉落状态，因为你已经要跳起来了
    states.Change<FallPlayerState>();
    // 发送跳跃事件
    playerEvents.OnJump?.Invoke();
}
```

打开PlayerStats，声明属性

```csharp
[Header("Jump Stats")] 
public int multiJumps = 1;
public float coyoteJumpThreshold = 0.15f;
public float maxJumpHeight = 17f;
public float minJumpHeight = 10f;
```

打开PlayerInputManager，我们来监听跳跃按键

```csharp
protected InputAction m_jump;
// 要注意声明一个可空值类型，这是记录上次跳跃的时间
protected float? m_lastJumpTime;
// 常量，跳跃的间隔
protected const float k_jumpBuffer = 0.15f;

protected virtual void Update()
{
    // 持续检测是否按下跳跃键
    if (m_jump.WasPressedThisFrame())
    {
        // 按下的时候就更新跳跃时间
        m_lastJumpTime = Time.time;
    }
}

protected virtual void CacheActions()
{
    m_movement = actions["Movement"];
    m_run = actions["Run"];
    // 要记得添加跳跃的动作
    m_jump = actions["Jump"];
}


// 先看这里

// 实现跳跃按下时的操作
public virtual bool GetJumpDown()
{
    // 当上次跳跃的时间不为空时 且 按键持续时间在范围内
    // 这里 m_lastJumpTime 和 k_jumpBuffer 没有声明，在上面声明它们
    if (m_lastJumpTime != null && Time.time - m_lastJumpTime < k_jumpBuffer)
    {
        // 设置上次跳跃时间为空
        m_lastJumpTime = null;
        // 能跳
        return true;
    }
    // 否则不能跳
    return false;
}

public virtual bool GetJumpUp()
{
    // 检测这一帧跳跃键是否松开
    return m_jump.WasReleasedThisFrame();
}
```

然后打开IdlePlayerState，WalkPlayerState，BrakePlayerState，都加上跳跃的检测函数

```csharp
protected override void OnStep(Player entity)
{
    entity.Jump();
    .....
}
```

此时运行游戏，就能跳了，但是会有报错。\
给PlayerEvents类加上序列化特性就好了

```csharp
[System.Serializable] 
```