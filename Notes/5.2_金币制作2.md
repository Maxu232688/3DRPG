# 金币制作

我们要对Player的Tag进行初始化，所以要在Player脚本中做一些操作。

```csharp
protected virtual void InitializeTag() => tag = GameTags.Player;

protected override void Awake()
{
    ...
    // 加上初始化tag
    InitializeTag();
}
```

打开Entity，我们需要在碰撞触发时进行一些处理

[Physics.OverlapCapsule](http://roundwide.com/physics-overlap-capsule/)

```csharp
protected Collider[] m_contactBuffer = new Collider[10];
protected CapsuleCollider m_collider;

// 这个函数目的是为了获取到与角色的胶囊体 碰撞到 的所有collider
public virtual int OverlapEntity(Collider[] result, float skinOffset = 0)
{
    var contactOffset = skinOffset + controller.skinWidth + Physics.defaultContactOffset;
    var overlapsRadius = radius + contactOffset;
    var offset = (height + contactOffset) * 0.5f - overlapsRadius;
    var top = position + Vector3.up * offset;
    var bottom = position + Vector3.down * offset;
    // 以上都是在计算检测胶囊体的大小的参数
    return Physics.OverlapCapsuleNonAlloc(top, bottom, overlapsRadius, result);
}

// 先从这里看起
protected virtual void Update()
{
    if (controller.enabled)
    {
        HandleState();
        HandleController();
        HandleGround();
        // 我们添加了一个新的控制，在碰撞时要做的事情
        HandleContacts();
    }
}
// 接触了要做什么
protected virtual void HandleContacts()
{
    // 这里获取到和当前实体接触的所有的碰撞体的数组
    var overlaps = OverlapEntity(m_contactBuffer);
    // 遍历整个数组
    for (int i = 0; i < overlaps; i++)
    {
        // 如果 碰到的实体不是Trigger 且 碰撞的实体和自身的位置不同
        if (!m_contactBuffer[i].isTrigger && m_contactBuffer[i].transform != transform)
        {
            // 那他们就接触了，这里直接去看OnContact是如何写的
            OnContact(m_contactBuffer[i]);
            // 接触完了我们就需要拿到它的监听，这是一个接口，有同样行为的都会被获取到这里，我们知道我们现在只做了一个ItemBox继承了这个接口，如果以后添加了新的东西，那么在同时接触它们的时候，就要把它们的接触后发生的功能全部开启
            var listeners = m_contactBuffer[i].GetComponents<IEntityContact>();
            // 遍历整个数组
            foreach (var contact in listeners)
            {
                // 触发实体的接触，这是我们早就实现的函数。虽然现在只有一个ItemBox有这个功能。ItemBox中只做了它被碰到触发了要做什么，这里做的是判断人如何去触发它。
                contact.OnEntityContact((T)this);
            }

            // 最后这里我们要改一下碰到东西后实体的速度，还记得课程中顶箱子浮在半空的bug吗，就在这里解决。
            // 判断 被碰撞的底部是否 大于 去碰撞实体的头部
            if (m_contactBuffer[i].bounds.min.y > controller.bounds.max.y)
            {
                // 就是说如果在下面去顶，就要把速度设置为0，不能让它在往上飞了。
                // 这里取小值的时候，你可以想象一下如果我在头顶放了个弹簧，那是不是要加速下落呢？
                verticalVelocity = Vector3.Min(verticalVelocity, Vector3.zero);
            }
        }
    }
}

protected virtual void OnContact(Collider other)
{
    if (other)
    {
        // 接触时根据各个状态要做出不同的反应，这里需要在EntityStateManager中实现
        states.OnContact(other);
    }
}
```

在EntityStateManager中实现 OnContact

```csharp
public virtual void OnContact(Collider other)
{
    // 当当前状态不是空 且 没有暂停时
    if (current != null && Time.timeScale > 0)
    {
        // 触发当前状态的OnContact函数，这需要在EntityState中声明
        current.OnContact(entity, other);
    }
}
```

在EntityState中声明这个抽象函数

```csharp
public abstract void OnContact(T entity, Collider other);
```

这时候你发现具体的状态类都报错了，是的，我们需要具体的在状态类中实现它，但是现在先返回到最上面，因为我们的函数还没有解读完。

在解读完Entity中的功能后，我们需要在各个具体的状态中实现接触函数

以目前现有的状态来说，人只有在走路或者下落的时候才有可能跟别的东西发生接触，idle和刹车的时候不会发生这些。

所以在IdlePlayerState中和BrakePlayerState中，什么也不做

```csharp
public override void OnContact(Player entity, Collider other)
{
}
```

在WalkPlayerState和FallPlayerState中：

```csharp
public override void OnContact(Player entity, Collider other)
{
    entity.PushRigidbody(other);
}
```

我们打开Player，实现这个函数

```csharp
// 在顶到物体的时候，仅仅把速度设置为0就足够了吗？有没有可能这个被顶的物体也得运动呢
public virtual void PushRigidbody(Collider other)
{
    // 如果 这个被顶的物体的最高点不在台阶偏移量之下 且 能够尝试获取到这个被顶物体的刚体
    if (!IsPointUnderStep(other.bounds.max) && other.TryGetComponent(out Rigidbody rigidbody))
    {   // 如果没有刚体则说明这个物体是固定在场景中的，不能被推动
        // 计算推力
        var force = lateralVelocity * stats.current.pushForce;
        // 给被顶的物体增加速度，越重加的速度越少（越难被推动）
        rigidbody.velocity += force / rigidbody.mass * Time.deltaTime;
    }
}
```

好了，到现在到Unity中运行，你就能发现可以顶出金币了。