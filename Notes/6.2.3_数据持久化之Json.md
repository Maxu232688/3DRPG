# 数据持久化之Json

Unity中用于解析Json的工具是 JsonUtility\
和我们在读取存档相关的方法中使用的是同一个东西

## 存储与读取字符串

```cs
// 用到的是File工具类进行读取
string str = "存档";
File.WriteAllText("路径", str); // 路径必须存在，否则会报错

string readStr = File.ReadAllText("路径");
```

## 使用JsonUtility进行序列化

```cs
public class Item
{
    public string name;
    public float weight;

    public Item(string name, float weight)
    {
        this.name = name;
        this.weight = weight;
    }
}

public class GameData
{
    // 给个初始值方便演示
    public float time = 12f;
    public int coins = 5;
    public string name = "测试";
    public bool access = true;

    public int[] id = new int[] {1,2,3,4};
    public List<int> id2 = new List<int>() {1,2,3};
    public Dictionary<int, string> dic = new Dictionary<int, string>() {{1, "123"}, {2, "234"}, {3, "345"}};

    public Item item1 = new Item("箱子", 2f);
    public List<Item> item2 = new List<Item>() {new Item("木板"， 1f), new Item("背包", 0.5f)};

    private int m_i = 5;
    protected int m_i2 = 10;
}
// 把gamedata类序列化
```

```cs
// 在需要序列化这个类的的地方：
GameData gameData = new GameData();
string jsonData = JsonUtility.ToJson(gameData);
File.WriteAllText("路径", jsonData);
```

不难发现，保存得到的json中有以下问题：

1. float存在json中，打开json去看数据时会有误差。
    这个问题无需关心，再次读取到unity中的数据依然是正确的。
2. 字典类型，自定义Item类类型，私有保护成员都没有被存储下来。
    JsonUtility不支持字典类型的存储。
    自定义类需要加上序列化特性`[System.Serializable]`
    要序列化私有保护变量，需要给该成员加上特性`[SerializeField]`
    JsonUtility存储null对象时的值不是null，而是默认值。如果上文中的`item1 = null`，存储得到的结果将是一个已经构造的item对象，且它的成员都是其默认值

```cs
[System.Serializable]
public class Item
{
    ...
}
// 最外层类，即要存储的对象不需要序列化特性，只有包裹在该类内部的对象需要序列化特性
public class GameData
{
    ...
    // 私有保护变量要加了这个特性才能存下来
    [SerializeField]
    private int m_i = 5;
    [SerializeField]
    protected int m_i2 = 10;
}
```

## 反序列化

```cs
string readStr = File.ReadAllText("路径");
// 用这两种方式都可以
GameData gD = JsonUtility.FormJson(readStr, typeof(GameData)) as GameData;
GameData gD2 = JsonUtility.FromJson<GameData>(readStr);
```

如果Json中的数据少了，读取到内存中后也不会报错，只是会把没有的数据在类中置空。\
如果类中的变量名与json中的键名不同，它们也是无法对应上的，读取后类中的数据会因为没有被对应而置空，而读取到的json数据会因为没有对应的变量被舍弃。

1. JsonUtility无法直接反序列化数据集合

什么意思呢，就是Json里面存储的数据是以数组形式存储的，比如

```json
[
    {"hp":3, "speed":4, "volume":5},
    {"hp":1, "speed":2, "volume":3},
    {"hp":2, "speed":4, "volume":4},
    {"hp":6, "speed":7, "volume":1}
]
```

这样类型的json它是反序列化不了的，必须要将其转换为class的类型

```json
{
    "list" : [
        {"hp":3, "speed":4, "volume":5},
        {"hp":1, "speed":2, "volume":3},
        {"hp":2, "speed":4, "volume":4},
        {"hp":6, "speed":7, "volume":1}
    ]
}
```

2. 文本编码格式必须是UTF-8，否则读取不了

---

另外还有一个好用的Json的序列化工具LitJson，它支持字典且不需要加序列化特性。

LitJson支持字典存储，要注意的是字典的键在Json里面会变成字符串的形式，你读出来的时候可能会因为字典类型不匹配出问题。

[LitJson官网](https://litjson.net/)