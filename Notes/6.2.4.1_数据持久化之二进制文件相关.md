# 数据持久化之二进制文件相关

二进制文件的安全性更高一些，因为json和xml的可读性高，很容易被外部修改\
二进制文件的效率也更高\
网络通信中会使用到相关的知识

## 各类型数据转字节数据

变量的本质就是二进制数据，在内存中以字节的形式存储\
1byte = 8bit\
bit位不是0就是1

### 二进制文件读写的本质

它就是通过将各类型变量转换为字节数组，将字节数组直接存储到文件中\
一般人是看不懂存储的数据的\
不仅可以节约存储空间，提升效率，还可以提升安全性\
而且在网络通信中我们直接传输的数据也是字节数据(2进制数据)

### 各类型数据和字节数组的相互转换

用BitConverter类去转换

```cs
int a = 99;
byte[] bytes = BitConverter.GetBytes(a); 
// 那么int类型转换到二进制，那就占4个字节，所以这个byte数组长度就是4
// 在这里断点运行可以看到，bytes[0] = 99, bytes[1] = 0, bytes[2] = 0, bytes[3] = 0;
// 有点小端存储的意思了

// 二进制数组转int
int i = BitConverter.ToInt32(bytes, 0); 
// 这里要注意的是，这个bytes数组可以很长，我只要转其中的一个数字出来，那第二个参数就是传入一个索引，我要转换这个int32类型的数字，就是从0开始转四个字节回来。
```

你可以进去BitConverter看看它都支持哪些转换

BitConverter不支持decimal类型的转换，不过这玩意几乎不咋用。\
string类型也转不了。

### 标准编码格式

编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。\为保证编码的正确性，编码要规范化、标准化，即需有标准的编码格式。\
常见的编码格式有ASCII、ANSI、GBK、GB2312、UTF-8、GB1803e和UNICODE等。

游戏开发中常用编码格式 UTF-8\
中文相关编码格式 GBK\
英文相关编码格式 ASCII

在c#中有一个专门的编码格式类来帮助我们将字符串和字节数组进行转换

提前声明一下，下面所有的路径相关的字符串，都必须精确到文件本身，包含文件的后缀名，比如：\
`Application.dataPath + "/SaveFile.save"`\
后缀名按需选择

```cs
string str = "字符串转字节数组"
byte[] bytes2 = Encoding.UTF8.GetBytes(str);
// 转换回来的时候，有两种重载，一种可以规定转这个数组里面的一部分，比如下面这句，就是转 [0, 12) 的数据
string str2 = Encoding.UTF8.GetString(bytes2, 0, 12);
// 这种就是全部转换
string str3 = Encoding.UTF8.GetString(bytes2);
```

## 文件操作

### File公共类

```cs
// 文件是否存在
bool isExists = File.Exists("路径");
// 创建文件
FileStream fs = File.Create("路径");


// 写入文件
// 写入文件时，如果该文件已经存在，会将原来的文件覆盖。
// 将指定字节数组写入到文件中
File.WriteAllBytes("路径", bytes);
// 将指定的string数组内容一行行写入到指定路径中
string[] strs = new string[] {"123", "12313132lkfadf", "fadskjlkaf", "aaaaaaa"};
File.WriteAllBytes("路径", strs); 
// 注意，我们这里存的是字符串数组，所以存到文件里面打开看看是可读的，每个字符串结束都会回车，最后一个字符串完了也会回车，所以文件里面会有5行，只不过第5行是空的

// 将指定字符串写入指定路径
File.WriteAllText("路径", "123132123123123123");
// 支持转义字符


// 读取文件
// 读取二进制数据
byte[] newBytes = File.ReadAlBytes("路径");
// 读取所有行信息
string[] newStrs = File.ReadAllLines("路径");
// 读取所有文本信息
string newStr = File.ReadAllText("路径");


// 删除文件
// 删除打开的文件会报错
File.Delete("路径");


// 复制文件
File.Copy("现有文件（要求流关闭）", "目标路径", true); // 第三个参数：如果目标路径的文件存在，填写true将其覆盖

// 替换文件
File.Replace("用谁替换", "谁被替换", "被替换的文件备份到哪");

// 以流的形式 打开文件写入或读取
// 参数： 文件路径，打开模式，访问模式
FileStream fs = File.Open("路径", FileMode.OpenOrCreate, FileAccess.ReadWrite);
```

## 文件流

### 文件流是什么

在c#中提供了一个文件流类 FileStream类，它主要作用是用于读写文件的细节\
我们之前学过的File只能整体读写文件，而FileStream可以以读写字节的形式处理文件

文件里面存储的数据就像是一条数据流(数组或者列表)，我们可以通过FileStream一部分一部分的读写数据流\
比如我可以先存一个int(4个字节)再存一个bool(1个字节)再存一个string (n个字节)，利用FileStream可以以流式逐个读写

### 文件流怎么用

```cs
// 打开或创建文件

//方法一：new FileStream
//参数一：路径
//参数二：打开模式
//  CreateNew:创建新文件 如果文件存在 则报错
//  Create:创建文件，如果文件存在 则覆盖
//  Open:打开文件，如果文件不存在 报错
//  OpenOrCreate:打开或者创建文件根据实际情况操作
//  Append:若存在文件，则打开并查找文件尾，或者创建一个新文件
//  Truncate:打开并清空文件内容
//参数三：访问模式
//参数四：共享权限  可以不写
//  None 谢绝共享
//  Read 允许别的程序读取当前文件
//  Write 允许别的程序写入该文件
//  ReadWrite 允许别的程序读写该文件
FileStream fs1 = new FileStream("路径", FileMode.Create, FileAccess.ReadWrite)

//方法二：File.Create
//参数一：路径
//参数二：缓存大小 (字节数，可以不写)
//参数三：描述如何创建或覆盖该文件（不常用）
//  Asynchronous 可用于异步读写
//  DeleteOnClose 不在使用时，自动删除
//  Encrypted 加密
//  None 不应用其它选项
//  RandomAccess 随机访问文件
//  SequentialScan 从头到尾顺序访问文件
//  WriteThrough 通过中间缓存直接写入磁盘
FileStream fs2 = File.Create("路径", 2048, FileOptions.None);

//方法三：File.Open
//参数一：路径
//参数二：打开模式
FileStream fs3 = File.Open("路径", FileMode.Open);

// 文件流打开用完一定要关闭
fs1.Dispose();
fs2.Dispose();
fs3.Dispose();



// 重要的属性和方法
FileStream fs = new FileStream(Application.persistentDataPath + "/test.save", FileMode.OpenOrCreate, FileAccess.ReadWrite);
// 文本字节长度
int len = fs.Length;
// 是否可写
if (fs.CanWrite)
{
    // 写入字节
    byte[] bytes = BitConverter.GetBytes(999);
    // 参数：要写入的字节数组，开始的索引，要写入多少个字节
    fs.Write(bytes, 0, 4);

    // 写入字符串
    // 要先写入字符串长度，再写入内容
    byte[] strBytes = Encoding.UTF8.GetBytes("测试字符串数组");
    fs.Write(BitConverter.GetBytes(strBytes.Length), 0, 4);
    fs.Write(strBytes, 0, strBytes.Length);
}

// 是否可读（确认权限）
if (fs.CanRead)
{
    // 这里读取文件内容，因为我们上面存了一个int和一个字符串，所以就举例把这两个东西读出来

    // 读取文件内容
    byte[] bytes2 = new byte[4];
    // 参数：读出来的内容存在哪个容器，容器中开始的位置，读取多少个字节装入容器
    // 返回值：当前流索引前进了几个位置
    int index = fs.Read(bytes2, 0, 4); // 这里读了4个字节，流索引就前进了4个位置
    int i = BitConverter.ToInt32(bytes2, 0);

    // 读取字符串
    // 先读字符串字节数组长度
    index = fs.Read(bytes2, 0, 4); // 这里索引已经前进到4了，就是从4开始再读4个
    int length = BitConverter.ToInt32(bytes2, 0);
    byte[] strBytes2 = new byte[length];
    index = fs.Read(strBytes2, 0, length);
    string str2 = Encoding.UTF8.GetString(strBytes2);
}

// 将信息加入字节流后，要将字节流中的内容写到文件上面，要执行这句
// 可以理解为马桶冲水把东西冲下去
fs.Flush();

// 关闭流 为了安全，把马桶盖关上，别让什么乱七八糟的东西都掉进去了
fs.Close();
// 缓存资源销毁回收
fs.Dispose();


// 还有一种读取方式，一次性先全部读出来，然后再慢慢去整理
FileStream fss = File.Open(Application.persistentDataPath + "/test.save", FileMode.Open, FileAccess.Read);

byte[] allBytes = new byte[fss.Length];
// 要注意的是，这里fss.Length的类型是 long，如果你的文件很大，说明它很长，很长就不适合用这种方式去读取了，很短的小文件可以这样读
fss.Read(allBytes, 0, (int)fss.Length); 
// 全都拿出来了，文件就没啥用了，直接关了
fss.Dispose();
// 读取数字
int i = BitConverter.ToInt32(allBytes, 0);
// 读取字符串
int length2 = BitConverter.ToInt32(allBytes, 4);
string readStr = Encoding.UTF8.GetString(allBytes, 8, length2);


// 更加安全的使用文件流对象

//using关键字重要用法
//using (申明一个引用对象)
//{
//   使用对象
//}
//无论发生什么情况 当using语句块结束后 
//会自动调用该对象的销毁方法 避免忘记销毁或关闭流
//using是一种更安全的使用方法

//强调：
//目前我们对文件流进行操作 为了文件操作安全 都用using来进行处理最好

using (FileStream fss = File.Open(Application.persistentDataPath + "/test.save", FileMode.Open, FileAccess.Read))
{
byte[] allBytes = new byte[fss.Length];
fss.Read(allBytes, 0, (int)fss.Length); 

int i = BitConverter.ToInt32(allBytes, 0);
int length2 = BitConverter.ToInt32(allBytes, 4);
string readStr = Encoding.UTF8.GetString(allBytes, 8, length2);

// 假如忘了写这句代码，也不会因为文件没关闭出错了，因为using结束就自动销毁了。
//fss.Dispose();
}
```

## 操作文件夹

平时我们可以在操作系统的文件管理系统中通过一些操作增删查改文件夹

我们目前要学习的就是通过代码的形式来对文件夹进行增删查改的操作

```cs
// 文件夹是否存在，要注意的是文件夹路径和文件路径的不同之处
if (Directory.Exists("路径"))
{

}

// 创建文件夹，如果文件夹存在，则不新建文件夹，只返回文件夹信息
DirectoryInfo info = Directory.CreateDirectory("路径");

// 删除文件夹，第二个参数：是否删除非空目录
Directory.Delete("路径", true);
// 如果不填第二个参数或者填false，在文件夹里面有内容的时候删除它会报错

// 查找文件夹
// 得到指定路径下的所有文件夹名
Directory.GetDirectories("路径"); // 只能得到文件夹名
// 得到指定目录下所有文件名
Directory.GetFiles("路径");

// 移动文件夹
Directory.Move("要移动的文件夹路径", "移动到哪里"); 
// 第二个参数所在路径的文件夹存在则会报错
// 移动会把文件夹内的内容也一起移动


// DirectoryInfo
// 上面已经展示了在创建文件夹时获取到的文件夹信息对象
// 全路径
print(info.FullName);
// 文件夹的名字
print(info.Name);
// 父文件夹信息
DirectoryInfo info2 = Directory.GetParent("当前文件夹路径");
// 所有子文件夹信息
DirectoryInfo[] infos = info2.GetDirectories();

// FileInfo
// 获取文件夹下所有文件的信息
FileInfo[] fInfos = info.GetFiles();
// 具体有什么方法可以去看FileInfo的源码
```