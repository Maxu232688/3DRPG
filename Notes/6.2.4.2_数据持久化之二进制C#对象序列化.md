# 数据持久化之二进制C#对象序列化

## 序列化

如果要使用C#自带的序列化到二进制的方法，必须在声明类时带上`[System.Serializable]`特性。

只要是涉及到的类，必须带上这个特性，否则报错

```cs
[System.Serializable]
public struct MyStruct
{
    public int i;
    public string s;

    public MyStruct(int i, string s)
    {
        this.i = i;
        this.s = s;
    }
}

[System.Serializable]
public class MyClass
{
    public int a = 10;

}

[System.Serializable]
public class Person
{
    public string name = "小红";
    public int age = 18;
    public int[] numbers = new int[] {1,2,3,4};
    public List<int> list = new List<int>() {1,2,3,4,5,6};
    public Dictionary<int, string> dic = new Dictionary<int, string>() {{1, "abc"}, {2, "adfac"},{3, "dfag"}};
    public MyStruct ms = new MyStruct(2, "afdfa");
    public MyClass mc = new ClassTest();
}
```

开始序列化

```cs
Person p = new Person();

//方法一：使用内存流得到2进制字节数组
//主要用于得到字节数组 可以用于网络传输
//新知识点
//1.内存流对象
//类名：MemoryStream
//命名空间：System.IO
//2.2进制格式化对象
//类名：BinaryFormatter
//命名空间：System.Runtime.Serialization.Formatters.Binary、
//主要方法：序列化方法 Serialize
using (MemoryStream ms = new MemoryStream())
{
    BinaryFormatter bf = new BinaryFormatter();
    // 序列化对象 并写到内存流中
    bf.Serialize(ms, p);
    // 从内存流中拿到对象的字节数组
    byte[] bytes = ms.GetBuffer();

    File.WriteAllBytes("路径", bytes);
    // 关闭内存流
    ms.Close();
}


//方法二：使用文件流进行存储
//主要用于存储到文件中
using (FileStream fs = new FileStream("路径", FileMode.OpenOrCreate, FileAccess.Write))
{
    BinaryFormatter bf = new BinaryFormatter();
    // 直接把序列化好的对象写到文件流中
    bf.Serialize(fs, p);
    fs.Flush();
    fs.Close();
}
```

## 反序列化

```cs
// 把文件中的内容反序列化了
using (FileStream fs = File.Open("路径", FileMode.Open, FileAccess.Read))
{
    BinaryFormatter bf = new BinaryFormatter();
    // 反序列化
    Person p1 = bf.Deserialize(fs) as Person;

    fs.Close();
}

// 网络传输过来的数据进行反序列化
// 假设我们已经通过网络通信拿到了一个字节数组
byte[] bytes = xxxxx;

using (MemoryStream ms = new MemoryStream(bytes))
{
    BinaryFormatter bf = new BinaryFormatter();
    Person p2 = bf.Deserialize(fs) as Person;
    ms.Close();
}
```

## 加密

**什么时候加密，什么时候解密？**

当我们将类对象转换为2进制数据时进行加密\
当我们将2进制数据转换为类对象时进行解密

这样如果第三方获取到我们的2进制数据\
当他们不知道加密规则和解密秘钥时就无法获取正确的数据\
起到保证数据安全的作用

**加密是否一定安全？**

一定记住加密只是提高破解门槛，没有100%保密的数据\
通过各种尝试始终是可以破解加密规则的，只是时间问题\
加密只能起到提升一定的安全性

### 常用的加密算法

MD5算法，SHA1算法，HMAC算法，AES/DES/3DES算法等等等

有很多的别人写好的第三发加密算法库可以直接获取用于在程序中对数据进行加密\
这就是信息安全的范畴了

我们整点简单的：

假如要加密一个数字 0001，密钥是 0010，我们让源数据和密钥异或一下

得到的结果是 0011，就是同一位不同的话就是1，相同的话就是0

此时我们要解密，那就再用密钥和加密过的数据异或一下

得到的结果是 0001

好的，我们来加密上面的Person类对象

```csharp
Person p = new Person();

byte key = 199; // 0~255

using (MemoryStream ms = new MemoryStream(bytes))
{
    BinaryFormatter bf = new BinaryFormatter();
    bf.Serialize(ms, p);
    byte[] bytes = ms.GetBuffer();

    for (int i = 0; i < bytes.Length; i++)
    {
        bytes[i] ^= key; // 异或
    }
    // 这里所有的字节都加密了

    // 解密就再执行一遍这样的循环
} 
```
