# 跳跃重击状态与保存转盘

**37节和38节倒过来了。**

---

在场景中创建一个空物体，命名为 End Level Panel。找到Models里面的 end_panel，拖到End Level Panel下当子物体。

给End Level Panel 加上Mesh Collider，勾选Convex，Mesh选择为EndPanel。

添加Audio Source。

挂上LevelController脚本。

然后把End Level Panel拖成预制体保存。

---

在Scripts\Misc中新建脚本Rotator

```csharp
public class Rotator : MonoBehaviour
{
    // 选择在哪个空间改变transform
    public Space space;
    public Vector3 eulars = new Vector3(0, -180, 0);
    
    protected void LateUpdate()
    {
        // 让挂了这个脚本的东西转
        transform.Rotate(eulars * Time.deltaTime, space);
    }
}
```

我们要做什么呢，要做一个旋转的盘子，然后人物跳上去重击它，就算是通关了。

那么在Misc下新建脚本Panel

```csharp
public class Panel : MonoBehaviour, IEntityContact
{
    public bool autoToggle;
    public bool requirePlayer;
    public bool requireStomp;
    
    protected Collider m_collider;
    protected Collider m_entityActivator;
    protected Collider m_otherActivator;
    protected AudioSource m_audio;
    public AudioClip activateClip;
    public AudioClip deActivateClip;

    public UnityEvent OnActivate;
    public UnityEvent OnDeActivate;
    
    public bool activated { get; protected set; }

    protected void Start()
    {
        // 首先，这个挂载了此脚本的物体标签得是Panel
        gameObject.tag = GameTags.Panel;
        // 然后初始化获取它身上的碰撞体和音效
        m_collider = GetComponent<Collider>();
        m_audio = GetComponent<AudioSource>();
    }

    protected void Update()
    {
        // 我们要看看到底是谁想激活它，那这两个东西是哪里来的呢？要看最下面的两个函数
        // 那么拿到这两个collider之后，它们中有一个存在就说明可以被触发，进入判断
        if (m_entityActivator || m_otherActivator)
        {
            // 算一下本物体的中心点
            var center = m_collider.bounds.center;
            // 算一下接触的偏移量（误差量）
            var contactOffset = Physics.defaultContactOffset + 0.1f;
            // 给 包围盒 的尺寸的y值加上误差量
            var size = m_collider.bounds.size + Vector3.up * contactOffset;
            // 新的包围盒就是我们算出来的数值
            var bounds = new Bounds(center, size);
            // 这里是bool类型的变量。Collider有bool运算符用来判断该对象是否存在。bounds.Intersects是在判断参数包围盒是否与该包围盒发生交叠
            // 那么从这里可以看出 如果是玩家发生交叠了，那就是true
            var intersectsEntity = m_entityActivator && bounds.Intersects(m_entityActivator.bounds);
            // 同理，如果是其他物体发生交叠了，就是true
            var intersectsOther = m_otherActivator && bounds.Intersects(m_otherActivator.bounds);
            // 只要有东西能触发
            if (intersectsEntity || intersectsOther)
            {
                // 激活触发
                Activate();
            }
            else
            {
                // 否则就置空，因为能进到这里的时候这两个变量肯定都是false
                m_entityActivator = intersectsEntity ? m_entityActivator : null;
                m_otherActivator = intersectsOther ? m_otherActivator : null;
                // 如果允许自动关闭
                if (autoToggle)
                {
                    // 就不激活了
                    DeActivate();
                }
            }
        }
    }

    public virtual void Activate()
    {
        // 如果没激活
        if (!activated)
        {
            // 激活音效存在时就播放激活音效
            if (activateClip)
            {
                m_audio.PlayOneShot(activateClip);
            }
            // 激活并发送事件
            activated = true;
            OnActivate?.Invoke();
        }
    }
    
    public virtual void DeActivate()
    {
        if (activated)
        {
            if (deActivateClip)
            {
                m_audio.PlayOneShot(deActivateClip);
            }

            activated = false;
            OnDeActivate?.Invoke();
        }
    }
    // 当实体与本物体发生接触的时候，这是实现接口的函数
    public void OnEntityContact(Entity entity)
    {
        // 如果这个实体的垂直速度小于 0 并且 踩到本物体上面了
        if (entity.velocity.y <= 0 && entity.IsPointUnderStep(m_collider.bounds.max))
        {
            // 如果 （不要求Player触发 或者 实体是玩家时）且（不要求重击此物体 或 玩家实体当前状态是 重击状态）
            // 简单来说就是可以被满足条件的实体触发
            if ((!requirePlayer || entity is Player) && 
                (!requireStomp || (entity as Player).states.IsCurrentOfType(typeof(StompPlayerState))))
            {
                // 那么拿到实体的collider
                // controller是角色控制器，继承Collider类，所以能用父类容器装
                m_entityActivator = entity.controller;
            }
        }
    }
    // 当有物体和本物体持续接触时，Collision类包含了接触点、冲击速度等信息。
    protected void OnCollisionStay(Collision other)
    {
        // 如果 既不要求玩家触发也不要求重击触发 且 接触物体的Tag不是玩家
        if (!(requirePlayer || requireStomp) && !other.collider.CompareTag(GameTags.Player))
        {
            // 那也就是其他的物体也能触发，拿到其他物体的collider
            m_otherActivator = other.collider;
        }
    }
}
```

[Unity3d bounds包围盒 和collider碰撞器区别](https://blog.csdn.net/u013628121/article/details/128117992)

打开EntityStateManager

```csharp
// 这是用来判断当前状态和传入状态是否一致的
public virtual bool IsCurrentOfType(Type type)
{
    if (current == null)
    {
        return false;
    }

    return current.GetType() == type;
}
```

那么写了这么一大堆，玩家的重击状态我们还没做呢。不过在此之前，需要先补充一些零碎的属性。

打开GameTags脚本

```csharp
// 加上panel的标签
public static string Panel = "Panel";
```

打开 PlayerStats

```csharp
// 一会要用到的一些重击状态时的参数
[Header("Stomp Attack Stats")] 
public bool canStompAttack = true;
public float stompAirTime = 0.8f;
public float stompDownwardForce = 20f;
public float stompGroundTime = 0.5f;
public float stompGroundLeapHeight = 10f;
```

在Scripts\Player\States下新建脚本StompPlayerState

```csharp
public class StompPlayerState : PlayerState
{
    // 玩家在空中的时间
    protected float m_airTimer;
    // 玩家在地面的时间
    protected float m_groundTimer;
    // 玩家是否在掉落
    protected bool m_falling;
    // 玩家是否已经着陆
    protected bool m_landed;
    // 这里进入状态的时候就要做一些事了
    protected override void OnEnter(Player entity)
    {
        // 初始化上面声明的变量
        m_landed = m_falling = false;
        m_airTimer = m_groundTimer = 0;
        // 玩家在重击状态时，先把垂直速度设置为0
        entity.velocity = Vector3.zero;
        // 我们很久以前写了一大堆事件，那么现在重击要开始了，发送事件
        entity.playerEvents.OnStompStarted?.Invoke();
    }

    protected override void OnExit(Player entity)
    {
        // 同样，退出重击状态的时候就要发送退出重击的事件
        entity.playerEvents.OnStompEnding?.Invoke();
    }

    protected override void OnStep(Player entity)
    {
        // 玩家没在掉落的时候（重击状态类中的掉落，不是玩家状态的掉落）
        if (!m_falling)
        {
            // 空中时间增加
            m_airTimer += Time.deltaTime;
            // 如果空中时间大于设定好的这个重击空中时间
            if (m_airTimer >= entity.stats.current.stompAirTime)
            {
                // 更改掉落状态（重击状态类中的，不是玩家的掉落状态）
                m_falling = true;
                // 发送重击之正在掉落的事件
                entity.playerEvents.OnStompFalling?.Invoke();
            }
        }
        else // 否则就是在掉落
        {
            // 更改玩家的垂直速度，加上 向下的重击力
            entity.verticalVelocity += Vector3.down * entity.stats.current.stompDownwardForce;
        }
        // 如果玩家落地了（玩家状态是落地状态了）
        if (entity.isGrounded)
        {
            // 重击类里如果还没有落地
            if (!m_landed)
            {
                // 那就改成落地，因为玩家已经落地了，在本类里面就要跟玩家状态一样
                m_landed = true;
                entity.playerEvents.OnStompLanding?.Invoke();
            }
            // 如果在地面上的时间 大于 这个设定好的重击落地时间
            if (m_groundTimer >= entity.stats.current.stompGroundTime)
            {
                // 给玩家加上一个向上的垂直速度（跳跃高度）
                entity.verticalVelocity = Vector3.up * entity.stats.current.stompGroundLeapHeight;
                // 切换玩家为掉落状态
                entity.states.Change<FallPlayerState>();
            }
            else // 否则就加时间
            {
                m_groundTimer += Time.deltaTime;
            }
        }
        // 重击就是跳起来砸地，在空中时要给一个向下的力来砸地，在地面上时要跳起来，然后这时就是在空中了。
    }

    public override void OnContact(Player entity, Collider other)
    {
    }
}
```

到此重击的状态就做差不多了。

回到Unity中，打开这个End Level Panel预制体，给它挂上Panel脚本。

勾选Require Player，Activate Clip 选择 Rise05。

添加OnActivate事件，把它本身拖给自己，选择Rotator.enabled
