# 转盘保存的实现

那么现在要让他踩上去有作用，就需要在LevelController里面加一个函数了

```csharp
public virtual void Finish() => m_finisher.Finish();
```

那么就要去实现Finish函数，打开LevelFinisher

```csharp
// 是否解锁下一关
public bool unlockNextLevel;
// 这关完了下一关去哪
public string nextLevelScene;
// 结束时发送的事件
public UnityEvent OnFinish;

protected Game m_game => Game.instance;
protected LevelScore m_score => LevelScore.instance;

protected virtual IEnumerator FinishRoutine()
{
    // 先取消暂停，并且进行结束设置
    m_pauser.Pause(false);
    m_pauser.canPause = false;
    // 分数中的计时器要停下来
    m_score.stopTime = true;
    m_level.player.inputs.enabled = false;
    
    yield return new WaitForSeconds(loadingDelay);
    // 如果能解锁下一关，那就解锁
    if (unlockNextLevel)
    {
        m_game.UnlockNextLevel();
    }
    // 解锁鼠标
    Game.LockCursor(false);
    // 分数结算
    m_score.Consolidate();
    // 加载下个场景
    m_loader.Load(nextLevelScene);
    OnFinish?.Invoke();
}

public virtual void Finish()
{
    // 同样的，结束了就停掉所有的携程，开始结算
    StopAllCoroutines();
    StartCoroutine(FinishRoutine());
}
```

很简单的逻辑，那么打开Game，实现这个解锁下一关的函数

```csharp
// 关卡是一个列表，所以我们要拿到当前关卡的索引值
public virtual int GetCurrentLevelIndex()
{
    var scene = GameLoader.instance.currentScene;
    return levels.FindIndex((level) => level.scene == scene);
}

public virtual void UnlockNextLevel()
{
    // 索引值加一，下一关
    var index = GetCurrentLevelIndex() + 1;
    // 不越界的时候就解锁
    if (index >= 0 && index < levels.Count)
    {
        levels[index].locked = false;
    }
}
```

接着我们实现分数结算，打开LevelScore

```csharp
public virtual void Consolidate()
{
    // 记录关卡不为空时
    if (m_level != null)
    {
        // 如果当前关卡记录的时间是0 或 这一把的时间小于记录时间
        if (m_level.time == 0 || time < m_level.time)
        {
            m_level.time = time;
        }
        // 金币比记录金币多时
        if (coins > m_level.coins)
        {
            m_level.coins = coins;
        }
        // 更新 星星
        m_level.stars = (bool[]) stars.Clone();
        // 请求存档
        m_game.RequestSaving();
    }
}
```

那么我们又回到了Game

```csharp
public UnityEvent OnSavingRequested;

public virtual LevelData[] ToLevelData()
{
    // 所有的Level数据都需要存储，每一个Level都要变成数据存进去
    return levels.Select(level => level.ToData()).ToArray();
}

public virtual GameData ToData()
{
    // 新建一个游戏数据对象返回去让Saver存储
    return new GameData()
    {
        retries = m_retries,
        // Level的数据也是单独的，所以同样的需要一个函数来做
        levels = ToLevelData(),
        createdAt = m_createAt.ToString(),
        updateAt = DateTime.UtcNow.ToString()
    };
}

public virtual void RequestSaving()
{
    // 掉Saver的Save函数，但是我们需要把当前的数据处理好
    GameSaver.instance.Save(ToData() ,m_dataIndex);
    OnSavingRequested?.Invoke();
}
```

我们打开GameLevel，来实现Level的ToData

```csharp
public virtual LevelData ToData()
{
    // 没什么好说的了，就是返回一个对应的LevelData对象
    return new LevelData()
    {
        locked = this.locked,
        coins = this.coins,
        time = this.time,
        stars = this.stars
    };
}
```

回到Unity中，打开End Level Panel，再给OnActivate添加一个事件，选择LevelController.Finish。

打开_LEVEL_预制体，在LevelFinish中，填写NextLevelScene为 LevelSelect，不要勾选UnlockNextLevel。因为我们就只做了一个场景，没做别的关卡。

这时运行，只要踩到这个Panel上就能结束游戏并保存了。