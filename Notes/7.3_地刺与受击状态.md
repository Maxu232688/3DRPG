# 地刺与受击状态

这节课开头摆了一下场景，增加了地刺。\
给地刺加了box collider。然后要给它写脚本了。\
要记得拖成预制体。

我嫌截图麻烦就懒得弄了。

---

摆好场景后，我们就开始写脚本了。\
在Scripts\Misc下新建脚本Hazard

```csharp
// 既然是危险的刺，它要想有作用一定得有碰撞体
[RequireComponent(typeof(Collider))]
public class Hazard : MonoBehaviour, IEntityContact
{
    // 以后我们还可能会做液体的危险物这里就是选择液体还是固体
    public bool isSolid;
    // 是否只在它上方时才造成伤害
    public bool damageOnlyFromAbove;
    // 伤害值是多少
    public int damage = 1;

    protected Collider m_collider;
    
    protected void Awake()
    {
        // 将tag改为Hazard
        tag = GameTags.Hazard;
        // 获取到这个危险物的碰撞体
        m_collider = GetComponent<Collider>();
        // 如果是液体，那就要设置成trigger，不要有碰撞的物理效果
        m_collider.isTrigger = !isSolid;
    }

    protected virtual void TryToApplyDamageTo(Player player)
    {
        // 因为伤害是有一定条件才能触发的，所以是尝试伤害
        // 如果 不是一定要在它上面才能伤害 或者 玩家的垂直速度小于0 且 玩家在这个危险物的上方
        if (!damageOnlyFromAbove || player.velocity.y <= 0 && player.IsPointUnderStep(m_collider.bounds.max))
        {
            // 这时候就满足伤害的条件了，应用伤害效果
            player.ApplyDamage(damage, transform.position);
        }
    }
    
    // 这里是实现继承接口的函数，在实体与它接触时
    public virtual void OnEntityContact(Entity entity)
    {
        // 如果实体是玩家，那就尝试伤害玩家
        if (entity is Player player)
        {
            TryToApplyDamageTo(player);
        }
    }
    // 这个函数是为了实现：如果你一直站在危险物上面，也要给出伤害
    protected void OnTriggerStay(Collider other)
    {
        // 如果这个碰撞的实体是玩家
        if (other.CompareTag(GameTags.Player))
        {
            // 能获取到玩家的这个脚本，那就尝试伤害
            if (other.TryGetComponent<Player>(out var player))
            {
                TryToApplyDamageTo(player);
            }
        }
    }
}
```

上面挖了很多坑，首先要补充一下这个Hazard的tag，打开GameTags

```csharp
public static string Hazard = "Hazard";
```

打开Player，写这个应用伤害的函数

```csharp
// 这个还没写完，先不研究它
public virtual void Throw()
{
    if (holding)
    {
        var force = lateralVelocity.magnitude * stats.current.throwVelocityMultiplier;
        //todo
        
    }
}

public override void ApplyDamage(int amount, Vector3 origin)
{
    // 如果 还有血量 且 不在这个受伤之后的无敌时间内
    if (!health.isEmpty && !health.recovering)
    {
        // 扣血
        health.Damage(amount);
        // 受伤了要改变人物的方向，需要面对这个危险物，那就算出这个伤害方向
        var damageDir = origin - transform.position;
        damageDir.y = 0;
        damageDir = damageDir.normalized;
        // 让玩家朝向这个危险物，这个函数和我们之前写的不一样
        FaceDirection(damageDir);
        // 重置 速度
        lateralVelocity = -transform.forward * stats.current.hurtBackwardsForce;
        // 如果 不是在水上受到伤害的
        if (!onWater)
        {
            // 修改垂直速度
            verticalVelocity = Vector3.up * stats.current.hurtUpwardsForce;
            // 改变为受击状态
            states.Change<HurtPlayerState>();
        }
        // 发送受伤事件
        playerEvents.OnHurt?.Invoke();
        // 如果血空了，那就要死了
        if (health.isEmpty)
        {
            Throw();
            playerEvents.OnDie?.Invoke();
        }
    }
}
```

由于我们又给人物加了很多属性，这里贴出PlayerStats全部的属性

```csharp
public class PlayerStats : EntityStats<PlayerStats>
{
    [Header("General Stats")] 
    public float rotationSpeed = 970f;
    public float friction = 16f;
    public float gravity = 38f;
    public float gravityTopSpeed = 50f;
    public float fallGravity = 65f;
    public float pushForce = 4f;
    public float snapForce = 15f;
    [Header("Motion Stats")] 
    public float brakeThreshold = -0.8f;
    public float turningDrag = 28f; 
    public float acceleration = 13f;
    public float topSpeed = 6f;
    public float airAcceleration = 32f;
    public float deceleration = 28f;
    [Header("Running Stats")] 
    public float runningAcceleration = 16f;
    public float runningTopSpeed = 7.5f;
    public float runningTurningDrag = 14f;
    [Header("Jump Stats")] 
    public int multiJumps = 1;
    public float coyoteJumpThreshold = 0.15f;
    public float maxJumpHeight = 17f;
    public float minJumpHeight = 10f;
    [Header("Stomp Attack Stats")] 
    public bool canStompAttack = true;
    public float stompAirTime = 0.8f;
    public float stompDownwardForce = 20f;
    public float stompGroundTime = 0.5f;
    public float stompGroundLeapHeight = 10f;
    [Header("Hurt Stats")] 
    public float hurtBackwardsForce = 5f;
    public float hurtUpwardsForce = 10f;
    [Header("Pick Throw Stats")] 
    public float throwVelocityMultiplier = 1.5f;

    // 14节内容，暂时没用
    [Header("Backflip Stats")] 
    public bool canBackflip = true;
    public float backflipJumpHeight = 23f;
    public float backflipGravity = 35f;
    public float backflipTurningDrag = 2.5f;
    public float backflipAirAcceleration = 12f;
    public float backflipTopSpeed = 7.5f;
    public float backflipBackwardTurnForce = 8f;
}
```

打开Health

```csharp
// 受击后的无敌时间
public float coolDown = 1f;
public UnityEvent OnDamage;

public virtual bool isEmpty => current == 0;
// 上次受击的时间
protected float m_lastDamageTime;
// 是否在无敌时间内
public virtual bool recovering => Time.time < m_lastDamageTime + coolDown;

public virtual void Damage(int amount)
{
    // 如果不在无敌时间内，就能扣血
    if (!recovering)
    {
        // 扣血 更新受击时间 发事件
        current -= Mathf.Abs(amount);
        m_lastDamageTime = Time.time;
        OnDamage?.Invoke();
    }
}
```

打开Entity，我们上面写了一个新的 改变面朝向的方法，在实体类里实现它，因为怪物也需要这样做

```csharp
public virtual void FaceDirection(Vector3 direction)
{
    // 如果方向确实存在
    if (direction.sqrMagnitude > 0)
    {
        // 计算出转向四元数
        var rotation = Quaternion.LookRotation(direction, Vector3.up);
        // 应用到物体上
        transform.rotation = rotation;
    }
}
```

那么扣血这一套顺下来了，现在需要添加上受击的状态和死掉的状态

在Scripts\Player\States下新建脚本HurtPlayerState

```csharp
public class HurtPlayerState : PlayerState
{
    protected override void OnEnter(Player entity){}

    protected override void OnExit(Player entity){}

    protected override void OnStep(Player entity)
    {
        // 受击时也要有重力
        entity.Gravity();
        // 如果玩家在地面上 且 垂直速度小等于0
        if (entity.isGrounded && (entity.verticalVelocity.y <= 0))
        {
            // 如果 血量还没空
            if (entity.health.current > 0)
            {
                // 那就变换为 idle
                entity.states.Change<IdlePlayerStates>();
            }
            else
            {
                // 没血了就变到死亡状态
                entity.states.Change<DiePlayerState>();
            }
        }
    }

    public override void OnContact(Player entity, Collider other){}
}
```

新建脚本 DiePlayerState

```csharp
public class DiePlayerState : PlayerState
{
    protected override void OnEnter(Player entity){}

    protected override void OnExit(Player entity){}

    protected override void OnStep(Player entity)
    {
        // 重力检测
        entity.Gravity();
        // 摩擦力检测（死了也会运动直到躺在地上，不能躺在地上还不停的滑行）
        entity.Friction();
        // 掉地上
        entity.SnapToGround();
    }

    public override void OnContact(Player entity, Collider other){}
}
```

再次打开Player

```csharp
public virtual void SnapToGround() => SnapToGround(stats.current.snapForce);
```

同样的，这个方法也需要到Entity里面实现，因为怪物也会死

```csharp
public virtual void SnapToGround(float force)
{
    // 如果在地上 且 垂直速度小等于0
    if (isGrounded && verticalVelocity.y <= 0)
    {
        // 给垂直速度一个向下的值
        verticalVelocity = Vector3.down * force;
    }
}
```

绕了这么多终于写差不多了，进入Unity，打开这个刺的预制体，挂上Hazard脚本，勾选isSolid。

打开Lily预制体，加上我们刚写的两个State

运行就能正常受击了。