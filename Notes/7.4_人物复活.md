# 人物复活

人物肯定是在关卡里面才能复活，所以在Scripts\Level下新建脚本LevelRespawener

```csharp
public class LevelRespawner : Singleton<LevelRespawner>
{
    // 还记得我们之前在 _GAME_ 里弄的那个黑色屏幕的UI 叫 Fade 吗，这里的时间就是控制它动画的时间的
    public float respawnFadeOutDelay = 1f;
    public float respawnFadeInDelay = 0.5f;
    public float gameOverFadeOutDelay = 5f;
    public float restartFadeOutDelay = 0.5f;
    // 相机列表
    protected List<PlayerCamera> m_cameras;
    // 一堆单例
    protected Level m_level => Level.instance;
    protected LevelPauser m_pauser => LevelPauser.instance;
    protected Game m_game => Game.instance;
    protected LevelScore m_score => LevelScore.instance;
    // Fader就是控制那个黑色屏幕的显隐的脚本，死了或者复活的时候要黑屏
    protected Fader m_fader => Fader.instance;

    public UnityEvent OnGameOver;
    public UnityEvent OnRespawn;
    // 死了肯定得重置相机
    protected virtual void ResetCameras()
    {
        foreach (var camera in m_cameras)
        {
            // 这个函数早就写好了，直接调用就行了
            camera.Reset();
        }
    }
    
    protected virtual IEnumerator GameOverRoutine()
    {
        // 那么gameover了就要结算了，先把计时器停了
        m_score.stopTime = true;
        // 等GameOver的黑屏时间
        yield return new WaitForSeconds(gameOverFadeOutDelay);
        // GameOver了就要重新开始这个关卡
        GameLoader.instance.Reload();
        OnGameOver?.Invoke();
    }

    protected virtual IEnumerator RespawnRoutine(bool consumeRetries)
    {
        // 复活时就扣掉一条命
        if (consumeRetries)
        {
            m_game.retries--;
        }
        // 让player进行复活
        m_level.player.Respawn();
        // 复活了金币也就没了
        m_score.coins = 0;
        // 重置相机
        ResetCameras();
        OnRespawn?.Invoke();
        
        yield return new WaitForSeconds(respawnFadeInDelay);
        // FadeIn传入一个回调
        m_fader.FadeIn(() =>
        {
            // 既然复活了，那么玩家操作就要恢复
            m_pauser.canPause = true;
            m_level.player.inputs.enabled = true;
        });
    }
    
    protected virtual IEnumerator Routine(bool consumeRetries)
    {
        // 还有命就复活，没命了就GameOver
        // 复活的时候要停止玩家的操作，游戏此时也不能暂停
        m_pauser.Pause(false);
        m_pauser.canPause = false;
        m_level.player.inputs.enabled = false;
        // 死掉的时候需要损耗命数 且 命数等于0时，那就是GameOver了
        if (consumeRetries && m_game.retries == 0)
        {
            StartCoroutine(GameOverRoutine());
            // yield break 就是退出本携程，相当于普通函数里面的return
            yield break;
        }
        // 等这个FadeOut的时间
        yield return new WaitForSeconds(respawnFadeOutDelay);
        // 否则就是要复活了
        m_fader.FadeOut(() => StartCoroutine(RespawnRoutine(consumeRetries)));
    }
    // 死亡事件发送后执行它
    public virtual void Respawn(bool consumeRetries)
    {
        // 既然都死了，那就得复活，先把所有携程停了，重新来过
        StopAllCoroutines();
        // 新开一个携程，去执行复活逻辑
        StartCoroutine(Routine(consumeRetries));
    }
    // 开始时，我们获取到所有的PlayerCamera
    protected void Start()
    {
        m_cameras = new List<PlayerCamera>(FindObjectsOfType<PlayerCamera>());
        // 给玩家死掉的时间加监听，死了才有可能复活，加的监听函数就是这个复活函数
        m_level.player.playerEvents.OnDie.AddListener(() => Respawn(true));
    }
}
```

依次来实现上面挖的坑，在Scripts\Misc下新建脚本Fader

```csharp
public class Fader : Singleton<Fader>
{
    // 渐变的速度
    public float speed = 1f;
    // 渐变控制的图片
    protected Image m_image;
    
    protected override void Awake()
    {
        base.Awake();
        // 拿到本身的这个图片
        m_image = GetComponent<Image>();
    }

    protected virtual IEnumerator FadeOutRoutine(Action onFinished)
    {
        // 调整这个图片的alpha值来达到显隐的效果
        while (m_image.color.a < 1)
        {
            // 如果不用携程，这里就会让程序卡住，所以用携程每帧的去改变这个图片的alpha值，不会卡住也达到了渐变的效果
            var color = m_image.color;
            color.a += speed * Time.deltaTime;
            m_image.color = color;
            yield return null;
        }
        // 执行完了就执行这个回调，即恢复玩家的操作
        onFinished?.Invoke();
    }

    protected virtual IEnumerator FadeInRoutine(Action onFinished)
    {
        // 这个跟上面的函数刚好就是反过来调整alpha值
        while (m_image.color.a > 0)
        {
            var color = m_image.color;
            color.a -= speed * Time.deltaTime;
            m_image.color = color;
            yield return null;
        }
        
        onFinished?.Invoke();
    }
    
    public void FadeOut(Action onFinished)
    {
        StopAllCoroutines();
        StartCoroutine(FadeOutRoutine(onFinished));
    }
    
    public void FadeIn(Action onFinished)
    {
        StopAllCoroutines();
        StartCoroutine(FadeInRoutine(onFinished));
    }
}
```

打开GameLoader

```csharp
public virtual void Reload()
{
    // 重新载入本关就行了
    StartCoroutine(LoadRoutine(currentScene));
}
```

打开Player

```csharp
protected Vector3 m_respawnPosition;
protected Quaternion m_respawnRotation;

protected virtual void InitializeRespawn()
{
    // 记录角色的重生位置
    m_respawnPosition = transform.position;
    m_respawnRotation = transform.rotation;
}

protected override void Awake()
{
    ...
    InitializeRespawn();
}

public virtual void Respawn()
{
    // 复活了血量就重置了
    health.Reset();
    // 重置角色的位置
    transform.SetPositionAndRotation(m_respawnPosition, m_respawnRotation);
    // 重生了肯定就改变到 idle 状态
    states.Change<IdlePlayerStates>();
}
```

打开Unity，打开 _LEVEL_预制体，挂上LevelRespawner。\
打开_GAME_预制体，激活Fader，把Fader图片的alpha调成0，挂上Fader脚本。

好了，现在运行，就能实现复活和GameOver了。