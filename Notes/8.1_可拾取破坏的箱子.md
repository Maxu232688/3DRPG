# 可拾取与破坏的箱子

陷阱相关的东西就做的差不多了，现在要做一些箱子，可以拿起来，可以丢出去，可以砸人，可以打烂。有内容物的箱子打烂了会掉出物品。

做之前你可以先去原工程里面玩一下，看看这个箱子都能干什么，捡起丢掉砸怪物，放水里能浮起来，打烂了爆出金币等等。

做预制体相关参数的图我这里就不放了，一个一个截图实在有点麻烦，建议一边看课一边看完全版工程对比着改。

这里我假设你已经做好了这个预制体，现在就是该写脚本了。

在Scripts\Misc下新建脚本 Breakable

```csharp
// 要想能被打烂，一定会有碰撞体，一定要有被打烂的音效
[RequireComponent(typeof(Collider), typeof(AudioSource))]
public class Breakable : MonoBehaviour
{
    // display就是箱子本身的这个模型
    public GameObject display;
    public AudioClip breakClip;
    
    protected Collider m_collider;
    protected AudioSource m_audioSource;
    protected Rigidbody m_rigidbody;

    public UnityEvent OnBreak;
    
    public bool broken { get; protected set; }
    
    public virtual void Break()
    {
        // 没打烂的时候才能打烂
        if (!broken)
        {
            // 有刚体的时候开启 isKinematic， 物体不受物理引擎控制，只能通过脚本直接修改其Transform来移动
            if (m_rigidbody)
            {
                m_rigidbody.isKinematic = true;
            }
            // 被打烂了就要设置相关的状态，让箱子模型消失掉等等
            broken = true;
            display.SetActive(false);
            m_collider.enabled = false;
            m_audioSource.PlayOneShot(breakClip);
            OnBreak?.Invoke();
        }
    }
    
    protected void Start()
    {
        m_collider = GetComponent<Collider>();
        m_audioSource = GetComponent<AudioSource>();
        // 有的能被打烂的东西没有刚体，所以这里尝试获取，有就拿没有就拉倒
        TryGetComponent(out m_rigidbody);
    }
}
```

`Rigidbody.isKinematic`：控制物理是否影响刚体。\
如果启用了 isKinematic，则力、碰撞或关节将不再影响刚体。 刚体将由动画或脚本通过更改 transform.position 进行完全控制。 运动刚体也会通过碰撞或关节影响其他刚体的运动。 例如，可以将运动刚体连接到一个具有关节的普通刚体上， 则该普通刚体将受到运动刚体运动的约束。 对于制作通常由动画驱动，但在特定情况下，可以通过将 isKinematic 设置为 false 来快速转变为布娃娃的角色， 运动刚体也极其有用。\
[Rigidbody.isKinematic](https://blog.csdn.net/ZeroBugX/article/details/145905822)

在Misc下新建脚本 Pickable

```csharp
// 我在给出的原工程里面试了一下，拿起箱子的时候箱子本身要变成trigger

[RequireComponent(typeof(Collider), typeof(Rigidbody))]
public class Pickable : MonoBehaviour, IEntityContact
{
    [Header("Attack Settings")] 
    public bool attackEnemies = true;
    public int damage = 1;
    public float minDamageSpeed = 5f;
    [Header("Respawn Settings")] 
    public bool autoRespawn;
    public bool respawnOnHitHazard;
    public float respawnHeightLimit = -100f;
    // 是不是正在被拿起
    public bool beingHold { get; protected set; }
    
    protected Collider m_collider;
    protected Rigidbody m_rigidbody;
    // 记录其原始信息，如果被拿起了父节点就要改成拿起它的实体，被丢了就要改回去
    protected Vector3 m_initialPosition;
    protected Quaternion m_initialRotation;
    protected Transform m_initialParent;

    protected void Start()
    {
        m_collider = GetComponent<Collider>();
        m_rigidbody = GetComponent<Rigidbody>();

        m_initialPosition = transform.localPosition;
        m_initialRotation = transform.localRotation;
        m_initialParent = transform.parent;
    }
    // 在与实体接触时
    public void OnEntityContact(Entity entity)
    {
        // 这里实现的就是用箱子砸怪物，如果：能用这个东西砸怪物 且 接触的实体是怪物 且 箱子的速度足够快以伤害怪物
        if (attackEnemies && entity is Enemy && m_rigidbody.velocity.magnitude > minDamageSpeed)
        {
            // 那就伤害
            entity.ApplyDamage(damage, transform.position);
        }
    }

    public virtual void Respawn()
    {
        // 所谓重生就是把箱子挪到原来的地方
        m_rigidbody.velocity = Vector3.zero;
        transform.parent = m_initialParent;
        transform.SetPositionAndRotation(m_initialPosition, m_initialRotation);
        // 既然都重生了，箱子的刚体就恢复，也不是trigger了，也没被拿起
        m_rigidbody.isKinematic = m_collider.isTrigger = beingHold = false;
    }
    // 这是干啥的？就是说有的箱子它碰到地刺啥的要消失，然后重新生成到原来的位置，你要是玩过传送门就有这个想法了，不小心把箱子弄掉坑里了会重新给你一个箱子
    protected virtual void EvaluateHazardRespawn(Collider other)
    {
        // 箱子能自动重生 且 箱子碰到陷阱会重生 且 碰到的东西是陷阱
        if (autoRespawn && respawnOnHitHazard && other.CompareTag(GameTags.Hazard))
        {
            Respawn();
        }
    }
    // 下面这两个函数，都是在碰撞时候触发的。
    // 由于我们想做的这个箱子挂了刚体，这两种检测碰撞的函数都是有可能被触发的。
    // 如果箱子和勾了Trigger的碰撞体碰撞了
    protected void OnTriggerEnter(Collider other)
    {
        EvaluateHazardRespawn(other);
    }
    // 如果箱子和没有勾Trigger的碰撞体碰撞了 或者 箱子本身勾了Trigger和任何检测碰撞的物体碰撞了
    public void OnCollisionEnter(Collision other)
    {
        EvaluateHazardRespawn(other.collider);
    }
}
```

[OnCollisionEnter、OnTriggerEnter与其子物体的联系](https://blog.csdn.net/qq_39108767/article/details/102818994)\
通过这个可以了解一下什么时候会触发OnTriggerEnter，什么时候会触发OnCollisionEnter

所以到现在还没做拿起箱子的功能，但是我们用到了Enemy类。

很显然Enemy和Player是一个层次的，在Scripts下新建文件夹Enemy，在其下新建脚本Enemy

```csharp
// 现在我们暂时还不做敌人，就空着让编译通过就行了
public class Enemy : Entity<Enemy>
{}
```

箱子扔水里要能浮起来，那就需要一个浮力脚本，在Misc下新建脚本 Bouyancy

```csharp
// 要做浮力那肯定得有刚体，因为这是物理学相关的玩意
[RequireComponent(typeof(Rigidbody))]
public class Bouyancy : MonoBehaviour
{
    // 浮力的大小
    public float force = 10f;
    
    protected Rigidbody m_rigidbody;
    
    protected void Start()
    {
        m_rigidbody = GetComponent<Rigidbody>();
    }

    protected void OnTriggerStay(Collider other)
    {
        // 就是说箱子在水里的时候
        if (other.CompareTag(GameTags.VolumeWater))
        {
            // 检测一下箱子在水面以下时
            if (transform.position.y < other.bounds.max.y)
            {
                // 越深浮力越大，所以这里算一下深度影响的倍乘系数，这个Clamp01就是限制得到的结果在 [0, 1] 中
                var multipler = Mathf.Clamp01(other.bounds.max.y - transform.position.y);
                // 浮力大小
                var bouyancy = Vector3.up * force * multipler;
                // 给箱子的刚体加力
                m_rigidbody.AddForce(bouyancy);
            }
        }
    }
}
```

那么这里多了个GameTag，打开GameTags

```csharp
public static string VolumeWater = "Volume/water";
```

回到Unity中，给这个箱子本身挂上Pickable和Breakable，添加OnBreak的事件监听，给coin挂上Rotator。

给Bouncy Coin挂上球星碰撞器，勾选isTrigger，半径设置为1。挂上Collectable，display拖入coin，particle拖入Coin Collection Particle，Clip 设置为 Coin01，Collision Clip 设置为 bouncy_item。\
再挂上 LevelController，把上面OnCollect监听事件设置为LevelController.AddCoins，数量为1.
