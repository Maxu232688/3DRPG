# 玩家攻击状态与打破箱子

打开Lily预制体，按课程中的操作添加碰撞盒的相关内容。

**所有新加的碰撞体必须勾选isTrigger**

在Scripts\Entity中创建脚本 EntityHitbox

```csharp
public class EntityHitbox : MonoBehaviour
{
    [Header("Attack Settings")] 
    public int damage = 1;
    public bool breakObjects = true;
    
    [Header("Rebound Settings")] 
    public bool rebound;
    public float reboundMinForce = 10f;
    public float reboundMaxForce = 25f;
    
    [Header("Push Back Settings")] 
    public bool pushBack;
    public float pushBackMinMagnitude = 5f;
    public float pushBackMaxMagnitude = 10f;
    
    protected Entity m_entity;
    protected Collider m_collider;
    // 首先初始化Entity
    protected virtual void InitializeEntity()
    {
        if (!m_entity)
        {
            // 注意，要拿到entity，要在它的父对象里面找，它本身挂载的地方肯定不是entity本身，而是entity下的碰撞盒
            m_entity = GetComponentInParent<Entity>();
        }
    }

    protected virtual void InitializeCollider()
    {
        // 拿到碰撞盒
        m_collider = GetComponent<Collider>();
        m_collider.isTrigger = true;
    }
    
    protected virtual void Start()
    {
        InitializeEntity();
        InitializeCollider();
    }

    protected virtual void HandleEntityAttack(Entity target)
    {
        // 攻击就应用伤害
        target.ApplyDamage(damage, transform.position);
    }

    protected virtual void HandleRebound()
    {
        // 如果能反弹
        if (rebound)
        {
            // 算出反弹力
            var force = -m_entity.velocity.y;
            force = Mathf.Clamp(force, reboundMinForce, reboundMaxForce);
            // 给自身施加反弹力
            m_entity.verticalVelocity = Vector3.up * force;
        }
    }

    protected virtual void HandlePushBack()
    {
        // 如果能推开
        if (pushBack)
        {
            // 给自身施加推开的力
            var force = -m_entity.lateralVelocity.magnitude;
            force = Mathf.Clamp(force, pushBackMinMagnitude, pushBackMaxMagnitude);
            m_entity.lateralVelocity = -transform.forward * force;
        }
    }

    protected virtual void HandleBreakableObject(Breakable breakable)
    {
        // 如果能打破物品
        if (breakObjects)
        {
            // 打破箱子
            breakable.Break();
        }
    }
    
    protected virtual void HandleCollision(Collider other)
    {
        // 如果这个打到的实体不是自身
        if (other != m_entity.controller)
        {
            // 拿到这个实体的对象
            if (other.TryGetComponent(out Entity target))
            {
                // 攻击
                HandleEntityAttack(target);
                HandleRebound();
                HandlePushBack();
            } // 如果拿不到实体对象，那就看看是不是可破坏的箱子
            else if (other.TryGetComponent(out Breakable breakable))
            {
                // 破坏箱子
                HandleBreakableObject(breakable);
            }
        }
    }

    protected virtual void HandleCustomCollision(Collider other)
    {
        // 自定义碰撞暂时空着
    }
    // 当发生碰撞时，即攻击碰撞盒碰到实体了
    protected void OnTriggerEnter(Collider other)
    {
        // 处理碰撞
        HandleCollision(other);
        HandleCustomCollision(other);
    }
}
```

那么碰撞盒的检测我们做好了，但是它被我们设置失活了，在攻击的时候才能激活，攻击完了又得失活，这就需要先去制作玩家的攻击状态了

先在PlayerInputManager里面加上对应的操作

```csharp
protected InputAction m_spin;

protected virtual void CacheActions()
{
    ....
    m_spin = actions["Spin"];
}

public virtual bool GetSpinDown()
{
    return m_spin.WasPressedThisFrame();
}
```

然后再打开Player，Spin是Player要实现的一个动作

```csharp
// 在空中时攻击的次数
public int airSpinCounter { get; protected set; }

public virtual void Spin()
{
    // 能不能在空中攻击 要靠 这些条件判断
    var canAirSpin = (isGrounded || stats.current.canAirSpin) && airSpinCounter < stats.current.allowedAirSpinCount;
    // 如果 能攻击 && 能在空中攻击 && 没有挂载墙上 && 检测到攻击输入
    if (stats.current.canSpin && canAirSpin && !holding && inputs.GetSpinDown())
    {
        // 如果不在地面上，那就给空中攻击次数+1
        if (!isGrounded)
        {
            airSpinCounter++;
        }
        // 切换到攻击状态
        states.Change<SpinPlayerState>();
        playerEvents.OnSpin?.Invoke();
    }
}
// 有时候切换了状态，还是需要向前挪动一些距离的
public virtual void AccelerateToInputDirection()
{
    // 以摄像机方向为准，向前挪动一些距离（1长度）
    var inputDirection = inputs.GetMovementCameraDirection();
    Accelerate(inputDirection);
}
```

那么来实现Spin状态，在Player\States下新建脚本 SpinPlayerState

```csharp
public class SpinPlayerState : PlayerState
{
    protected override void OnEnter(Player entity)
    {
        // 如果玩家不在地面上
        if (!entity.isGrounded)
        {
            // 在空中攻击要往上飞一下
            entity.verticalVelocity = Vector3.up * entity.stats.current.airSpinUpwardForce;
        }
    }

    protected override void OnExit(Player entity)
    {
    }

    protected override void OnStep(Player entity)
    {
        entity.Gravity();
        entity.SnapToGround();
        entity.AccelerateToInputDirection();
        
        // 如果进入状态的时间超过了攻击的时间，就要退出状态
        if (timeSinceEntered >= entity.stats.current.spinDuration)
        {
            // 在地面上时切换为idle，在空中时切换为fall
            if (entity.isGrounded)
            {
                entity.states.Change<IdlePlayerStates>();
            }
            else
            {
                entity.states.Change<FallPlayerState>();
            }
        }
    }

    public override void OnContact(Player entity, Collider other)
    {
    }
}
```

我们设置了很多stats，打开PlayerStats

```csharp
[Header("Spin Stats")] 
public bool canSpin = true;
public bool canAirSpin = true;
public int allowedAirSpinCount = 1;
public float airSpinUpwardForce = 10f;
public float spinDuration = 0.5f;
```

为了能够切换到Spin状态，我们需要在Walk状态，Idle状态和Fall状态的OnStep函数中都加入：

```csharp
entity.Spin();
```

那么攻击动作和状态是做好了，运行点击左键可以看到角色旋转了，但是现在没有把碰撞盒激活，打不了箱子。

在Entity下新建脚本 EntityStateManagerListener

```csharp
public class EntityStateManagerListener : MonoBehaviour
{
    public UnityEvent onEnter;
    public UnityEvent onExit;

    public List<string> states;

    protected EntityStateManager m_manager;

    protected void OnEnter(Type state)
    {
        if (states.Contains(state.Name))
        {
            onEnter?.Invoke();
        }
    }
    
    protected void OnExit(Type state)
    {
        if (states.Contains(state.Name))
        {
            onExit?.Invoke();
        }
    }

    protected void Start()
    {
        if (!m_manager)
        {
            m_manager = GetComponentInParent<EntityStateManager>();
        }
        
        m_manager.events.onEnter.AddListener(OnEnter);
        m_manager.events.onExit.AddListener(OnExit);
    }
}
```

这个类是为了将EntityStateManager中的进入和退出状态时发送的事件延申出来，我们要在它挂载的对象上面去监听这两个事件不需要单独给这个对象写脚本监听这两个事件了。

同时，在EntityStateManager中

```csharp
public virtual void Change(EntityState<T> toState)
{
    if (toState != null && Time.timeScale > 0)
    {
        if (current != null)
        {
            current.Exit(entity);
            // 加上当前状态退出了要发送的事件
            events.onExit.Invoke(current.GetType());
            last = current;
        }

        current = toState;
        current.Enter(entity);
        // 加上进入当前状态发送的事件
        events.onEnter.Invoke(current.GetType());
        // 加上状态改变发送的事件
        events.onChange?.Invoke();
    }
}
```

进入场景中，给Spin Hitbox挂上Entity Hitbox脚本，再挂上EntityStateManagerListener脚本。\
修改EntityStateManagerListener，进入状态时监听函数为BoxCollider.enabled = true，退出状态时为false。states数组加一，写上SpinPlayerState，因为要检测的就是这个状态，只有进入这个状态了才会激活碰撞盒。\
就是在这里激活了这个碰撞盒，让攻击开始检测。

至于跳跃的bug，是因为stomp hitbox里面的那个collider没有勾选isTrigger，在重力检测的时候是向下发射的球形射线检测脚下还有没有东西，显然这个不勾选isTrigger的话是会被当作一个实在的物体的。

当然，在课程中修改了FallPlayerState，这里也一并贴出修改的部分

```csharp
protected override void OnStep(Player entity)
{
    entity.Gravity();
    entity.SnapToGround();
    entity.FaceDirectionSmooth(entity.lateralVelocity);
    entity.AccelerateToInputDirection();
    entity.Jump();
    entity.Spin();
    if (entity.isGrounded)
    {
        entity.states.Change<IdlePlayerStates>();
    }
}
```

**到这里可能会有遗漏未记录的工作，如果你按照课程中的操作来做了，然后再通过阅读文档来改了bug，到此不会出现什么bug了，下一步是去实现抓起箱子了。**

**另外就是关于玩家状态机的部分，最好根据原工程去设置一下，一共20个状态，位置要对应。Stomp状态我们其实已经在这里做出来了，只不过没调用它。**

这里还有个bug，就是在空中的spin次数没有归零，进行过一次空中spin之后就再也不能空中spin了。

**这里在Player下新建一个脚本PlayerEventListener，原理和上面的EntityStateManagerListener一个样。**

```csharp
public class PlayerEventListener : MonoBehaviour 
{
    public Player player;
    public PlayerEvents events;

    protected virtual void InitializePlayer()
    {
        if (!player)
        {
            player = GetComponentInParent<Player>();
        }
    }

    protected virtual void InitializeCallbacks()
    {
        player.playerEvents.OnJump.AddListener(() => events.OnJump.Invoke());
        player.playerEvents.OnHurt.AddListener(() => events.OnHurt.Invoke());
        player.playerEvents.OnDie.AddListener(() => events.OnDie.Invoke());
        player.playerEvents.OnSpin.AddListener(() => events.OnSpin.Invoke());
        player.playerEvents.OnPickUp.AddListener(() => events.OnPickUp.Invoke());
        player.playerEvents.OnThrow.AddListener(() => events.OnThrow.Invoke());
        player.playerEvents.OnStompStarted.AddListener(() => events.OnStompStarted.Invoke());
        player.playerEvents.OnStompFalling.AddListener(() => events.OnStompFalling.Invoke());
        player.playerEvents.OnStompLanding.AddListener(() => events.OnStompLanding.Invoke());
        player.playerEvents.OnStompEnding.AddListener(() => events.OnStompEnding.Invoke());
        player.playerEvents.OnLedgeGrabbed.AddListener(() => events.OnLedgeGrabbed.Invoke());
        player.playerEvents.OnLedgeClimbing.AddListener(() => events.OnLedgeClimbing.Invoke());
        player.playerEvents.OnAirDive.AddListener(() => events.OnAirDive.Invoke());
        player.playerEvents.OnBackflip.AddListener(() => events.OnBackflip.Invoke());
        player.playerEvents.OnGlidingStart.AddListener(() => events.OnGlidingStart.Invoke());
        player.playerEvents.OnGlidingStop.AddListener(() => events.OnGlidingStop.Invoke());
        player.playerEvents.OnDashStarted.AddListener(() => events.OnDashStarted.Invoke());
        player.playerEvents.OnDashEnd.AddListener(() => events.OnDashEnd.Invoke());
    }

    protected void Start()
    {
        InitializePlayer();
        InitializeCallbacks();
    }
}
```