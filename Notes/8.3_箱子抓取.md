# 箱子抓取

摄像机我们是直接按照最终的工程调整的，这里不需要调整。

**这里代码中我看见加上了Stomp的控制，但之前的代码中没有涉及到。其实也很简单。**

首先打开PlayerInputManager

```csharp
    protected InputAction m_stomp;

    protected virtual void CacheActions()
    {
        ...
        m_stomp = actions["Stomp"];
    }

    public virtual bool GetStompDown() => m_stomp.WasPressedThisFrame();
```

然后再打开Player

```csharp
public virtual void StompAttack()
{
    // 如果 不在地面 且 没有抓在墙上 且 能重击 且 检测到重击输入
    if (!isGrounded && !holding && stats.current.canStompAttack && inputs.GetStompDown())
    {
        states.Change<StompPlayerState>();
    }
}
```

**然后在Spin和Fall还有Backflip（14节内容，没做就跳过）状态的OnStep中调用这个StompAttack函数即可。**

打开Lily预制体，现在实现砸地攻击。

给Stomp Hitbox挂上Entity Hitbox，取消勾选Break Objects，勾选 Rebounds。激活Box Collider，此时跳跃bug就不会出现了。

给Heavy Stomp Hitbox挂上EntityHitbox，勾选BreakObjects，再挂上Player Event Listener，开启 OnStompFalling 和 OnStompEnding，分别控制Heavy Stomp 的 BoxCollider，下落时打开碰撞体，结束时关闭。

---

打开Player，我们既然要捡起丢掉东西，那么这是玩家的一些动作，所以要在Player里面写

```csharp
// 捡起箱子的父节点
public Transform pickSlot;
// 捡起的箱子是谁
public Pickable pickable { get; protected set; }

public virtual void PickAndThrow()
{
    // 如果 能捡起东西 且 检测到按下拾取键
    if (stats.current.canPickUp && inputs.GetPickAndDropDown())
    {
        // 如果没有捡起东西
        if (!holding)
        {
            // 检测自己前方拾取距离内是否有东西
            if (CapsuleCast(transform.forward, stats.current.pickDistance, out var hit))
            {
                // 如果有东西看看是否是可以捡起的东西
                if (hit.transform.TryGetComponent(out Pickable pickable))
                {
                    // 如果是就捡起
                    PickUp(pickable);
                }
            }
        }
        else // 如果捡起了东西就丢掉
        {
            Throw();
        }
    }
}

public virtual void PickUp(Pickable pickable)
{
    // 如果没有在捡起东西 且 （在地面上 或 可以在空中捡起东西）
    if (!holding && (isGrounded || stats.current.canPickUpAir))
    {
        // 捡起
        holding = true;
        this.pickable = pickable;
        // 调用物品的被捡起函数
        pickable.Pick(pickSlot);
        // 捡起的东西要重新生成时，需要给它加一个监听函数
        pickable.OnRespawn.AddListener(RemovePickable);
        playerEvents.OnPickUp?.Invoke();
    }
}

public virtual void RemovePickable()
{
    // 如果在捡起的状态下箱子重新生成了，所以就要把手里的东西置空
    if (holding)
    {
        pickable = null;
        holding = false;
    }
}

public virtual void Throw()
{
    // 拿着东西的时候才能扔
    if (holding)
    {
        // 扔要有个力，力的大小和人物的速度有关
        var force = lateralVelocity.magnitude * stats.current.throwVelocityMultiplier;
        // 调用物品的释放方法
        pickable.Release(transform.forward, force);
        pickable = null;
        holding = false;
        playerEvents.OnThrow?.Invoke();
    }
}
```

先做简单的工作，在PlayerStats里面加上这些属性

```csharp
[Header("Pick Throw Stats")] 
public bool canPickUp = true; 
public float throwVelocityMultiplier = 1.5f;
public float pickDistance = 0.5f;
public bool canPickUpAir = false;
```

然后打开PlayerInputManager，加上捡起扔掉的按键行为

```csharp
protected InputAction m_pickAndDrop;

protected virtual void CacheActions()
{
    ...
    m_pickAndDrop = actions["PickAndDrop"];
}

public virtual bool GetPickAndDropDown() => m_pickAndDrop.WasPressedThisFrame();
```

打开Entity类，实现检测前方物体的函数

```csharp
// 调用处是这样的：CapsuleCast(transform.forward, stats.current.pickDistance, out var hit)
public virtual bool CapsuleCast(Vector3 direction, float distance, int layer = Physics.DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.Ignore)
{
    return CapsuleCast(direction, distance, out _, layer, queryTriggerInteraction);
}
// 调用的是这种，上面那种只不过是没有返回hit的同样方法
public virtual bool CapsuleCast(Vector3 direction, float distance,out RaycastHit hit, int layer = Physics.DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.Ignore)
{
    // 这里origin应该是多加了一次center，幸好center是(0，0，0)，不然就算错了
    // origin是 position 沿 direction 方向移动 radius 距离的点
    var origin = position - direction * radius /*+ center*/;
    // 这里offset就是角色胶囊体一半的高度（去掉半球高度的），这是个向量，方向向上
    var offset = transform.up * (height * 0.5f - radius);
    // top点就是origin向上挪动胶囊体中 offset的距离，这个点在角色胶囊体圆柱部分的最上面的圆上
    var top = origin + offset;
    // bottom 当然就在角色胶囊体圆柱的底部了
    var bottom = origin - offset;
    // 由 top 向 bottom 及 radius 确定了一个胶囊体A，向direction方向发射 distance + radius的距离，检测在这个距离内与这个胶囊体A碰撞的所有物体
    return Physics.CapsuleCast(top, bottom, radius, direction, out hit, distance + radius, layer, queryTriggerInteraction);
}
```

打开Pickable，实现物体本身被抓取后的操作

```csharp
[Header("General Settings")] 
public Vector3 offset;
public float releaseOffset = 0.5f;

protected RigidbodyInterpolation m_interpolation;

public UnityEvent OnPicked;
public UnityEvent OnRespawn; // 这个事件应该在Respawn函数里面invoke一下，不过目前课里面没写，我也就不写了，因为之后做会重生的箱子的时候肯定还会用到
public UnityEvent OnReleased;
    
public virtual void Pick(Transform slot)
{
    // 没被抓着的时候才能被抓
    if (!beingHold)
    {
        beingHold = true;
        // 绑定父节点到手上
        transform.parent = slot;
        // 移动位置和重置旋转，不要与拿起它的实体穿模了
        transform.localPosition = Vector3.zero + offset;
        transform.localRotation = Quaternion.identity;
        // 关掉一切的实体碰撞，拿起的箱子变虚
        m_rigidbody.isKinematic = true;
        m_collider.isTrigger = true;
        // 刚体插值，用以平滑物理运动的显示效果，默认是关闭的（None）。物理运动以离散的时间步运行，而显卡以可变的帧率渲染，这可能导致物体抖动。对于主角或相机跟随的物体，建议使用插值。
        // 也就是说这个箱子跟着玩家运动的时候关闭插值，因为没有需要物理判断了，不过在此之前要记录下它原来的插值属性，丢掉箱子的时候要重新设置
        m_interpolation = m_rigidbody.interpolation;
        m_rigidbody.interpolation = RigidbodyInterpolation.None;
        OnPicked?.Invoke();
    }
}

public virtual void Release(Vector3 direction, float force)
{
    // 拿着才能丢掉
    if (beingHold)
    {
        // 父节点置空
        transform.parent = null;
        // 丢掉物体时要避免和玩家碰撞，往丢掉的方向挪动一些距离
        transform.position += direction * releaseOffset;
        // 开启物理判断
        m_collider.isTrigger = m_rigidbody.isKinematic = beingHold = false;
        // 恢复插值
        m_rigidbody.interpolation = m_interpolation;
        // 加速
        m_rigidbody.velocity = direction * force;
        OnReleased?.Invoke();
    }
} 
```

在Fall，Idle，Walk状态中的OnStep中都加上：

```csharp
entity.SnapToGround();
entity.PickAndThrow(); 
```

在场景中，打开Lily预制体，在模型中的Hips下新建空节点Holding Slot，设置position为 0，0.5，0.5 ，然后将其挂给Player中的slot

打开可拾取箱子的预制体，调整pickable中的 offset 为 0，0.5，0.25，调整Release offset为0.25.

运行按G键即可拾取丢弃。