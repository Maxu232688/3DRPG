# 怪物基础逻辑

史莱姆

拖预制体的操作就不贴出来了，比较简单。

完善之前写的Enemy类

```csharp
public class Enemy : Entity<Enemy>
{
    // 敌人看见的物体
    protected Collider[] m_sightOverlaps = new Collider[1024];
    // 敌人能攻击到的物体
    protected Collider[] m_currentAttackOverlaps = new Collider[1024];
    // 有没有锁定player
    public Player player { get; protected set; }
    // 血量
    public Health health { get; protected set; }
    // 属性
    public EnemyStatsManager stats { get; protected set; }
    // 路线规划
    public WaypointManager waypoints { get; protected set; }
    // 事件
    public EnemyEvents enemyEvents;
    
    protected virtual void InitializeWaypointManager() => waypoints = GetComponent<WaypointManager>();
    protected virtual void InitializeStatsManager() => stats = GetComponent<EnemyStatsManager>();
    protected virtual void InitializeHealth() => health = GetComponent<Health>();
    protected virtual void InitializeTag() => tag = GameTags.Enemy;

    public virtual void Accelerate(Vector3 direction, float acceleration, float topSpeed) =>
        Accelerate(direction, stats.current.turningDrag, acceleration, topSpeed);

    public virtual void Decelerate() => Decelerate(stats.current.deceleration);

    public virtual void Friction() => Decelerate(stats.current.friction);

    public virtual void Gravity() => Gravity(stats.current.gravity);

    public virtual void SnapToGround() => SnapToGround(stats.current.snapForce);

    public virtual void FaceDirectionSmooth(Vector3 direction) => FaceDirection(direction, stats.current.rotationSpeed);

    // 在Update时，敌人要不断地去搜索player是否进入锁定范围
    protected virtual void HandleSight()
    {
        // 没有锁定player时
        if (!player)
        {
            // 用球形射线判断 以自己为中心半径为spotRange的范围内的所有碰撞体
            var overlaps = Physics.OverlapSphereNonAlloc(position, stats.current.spotRange, m_sightOverlaps);

            for (int i = 0; i < overlaps; i++)
            {
                // 如果发现Player
                if (m_sightOverlaps[i].CompareTag(GameTags.Player))
                {
                    if (m_sightOverlaps[i].TryGetComponent<Player>(out var player))
                    {
                        // 索敌
                        this.player = player;
                        enemyEvents.OnPlayerSpotted?.Invoke();
                        return;
                    }
                }
            }
        }
        else // 否则 就是已经锁定player
        {
            // 判断player和自己的距离
            var distance = Vector3.Distance(position, player.position);
            // 如果player死了或者距离太远了
            if (player.health.current == 0 || distance > stats.current.viewRange)
            {
                // 失去索敌
                player = null;
                enemyEvents.OnPlayerScaped?.Invoke();
            }
        }
    }
    // 接触攻击
    protected virtual void ContactAttack()
    {
        // 能接触攻击时
        if (stats.current.canAttackOnContact)
        {
            // 计算能接触到怪物的所有碰撞体
            var overlaps = OverlapEntity(m_currentAttackOverlaps, stats.current.contactOffset);

            for (int i = 0; i < overlaps; i++)
            {
                // 如果里面有player
                if (m_currentAttackOverlaps[i].CompareTag(GameTags.Player) && m_currentAttackOverlaps[i].TryGetComponent<Player>(out var player))
                {
                    // 计算 偏移量，怪物头顶减去 设定好的偏移量
                    var stepping = controller.bounds.max + Vector3.down * stats.current.contactSteppingTolerance;
                    // player在怪物头顶的时候能给怪物造成伤害，所以要判断player是不是在怪物上方
                    if (!player.IsPointUnderStep(stepping)) // 如果不在怪物上方
                    {
                        // 如果能被推开
                        if (stats.current.canContactPushBack)
                        {
                            // 施加推力给怪物
                            lateralVelocity = -transform.forward * stats.current.contactPushBackForce;
                        }
                        // 玩家受击
                        player.ApplyDamage(stats.current.contactDamage, transform.position);
                        enemyEvents.OnPlayerContact?.Invoke();
                    }
                }
            }
        }
    }

    public override void ApplyDamage(int amount, Vector3 origin)
    {
        // 如果血没空 且 不在无敌时间
        if (!health.isEmpty && !health.recovering)
        {
            // 受到伤害
            health.Damage(amount);
            enemyEvents.OnDamage?.Invoke();

            // 血空了就死掉
            if (health.isEmpty)
            {
                controller.enabled = false;
                enemyEvents.OnDie?.Invoke();
            }
        }
    }
    
    protected override void Awake()
    {
        base.Awake();
        InitializeTag();
        InitializeStatsManager();
        InitializeHealth();
        InitializeWaypointManager();
    }

    protected override void OnUpdate()
    {
        HandleSight();
        ContactAttack();
    }
}
```

那么就需要三个新的类：EnemyEvents，EnemyStats，EnemyStatsManager

EnemyEvents：

```csharp
[Serializable]
public class EnemyEvents
{
    public UnityEvent OnPlayerSpotted;
    public UnityEvent OnPlayerScaped;
    public UnityEvent OnPlayerContact;
    public UnityEvent OnDamage;
    public UnityEvent OnDie;
    public UnityEvent OnRevive;
}
```

EnemyStats：

```csharp
public class EnemyStats : EntityStats<EnemyStats>
{
    [Header("General Stats")]
    public float gravity = 35f;
    public float snapForce = 15f;
    public float rotationSpeed = 970f;
    public float deceleration = 28f;
    public float friction = 16f;
    public float turningDrag = 28f;
    [Header("View Stats")]
    public float spotRange = 5f;
    public float viewRange = 8f;
    [Header("Contact Attack Stats")]
    public bool canAttackOnContact = true;
    public bool canContactPushBack = true;
    public float contactOffset = 0.15f;
    public int contactDamage = 1;
    public float contactPushBackForce = 18f;
    public float contactSteppingTolerance = 0.1f;
    [Header("Follow Stats")]
    public float followAcceleration = 10f;
    public float followTopSpeed = 2.5f;
    [Header("Waypoint Stats")] 
    public bool faceWayPoint = true;
    public float waypointMinDistance = 0.5f;
    public float waypointAcceleration = 10f;
    public float waypointTopSpeed = 2f;
}
```

EnemyStatsManager：

```csharp
public class EnemyStatsManager : EntityStatsManager<EnemyStats>
{
}
```

在Script下新建文件夹Waypoint，在其下新建脚本WaypointManager

```csharp
public class WaypointManager : MonoBehaviour
{
}
```

在GameTag中添加Enemy的Tag：

```csharp
public static string Enemy = "Enemy";
public static string Platform = "Platform";
public static string Spring = "Spring";
```

在unity中，新建 Enemy，Platform 和 Spring 的 Tag。

在Entity中加入OnUpdate，顺便在这里修一些bug

```csharp
public float groundAngle { get; protected set; }
public Vector3 groundNormal { get; protected set; }
public Vector3 localSlopeDirection { get; protected set; }

// 给update函数的判断加上后面这部分
// 因为如果不论是玩家或者是怪物，要么有CharacterController，要么就需要胶囊碰撞体
protected virtual void Update()
{
    if (controller.enabled || m_collider != null)
    {
        ...
        // 在这里加上
        OnUpdate();
    }
}

protected virtual void OnUpdate()
{ // 空着就行了
}
// HandleGround 也需要进行修改
protected virtual void HandleGround()
{
    // 首先我们要计算角色离地面的高度，这个高度就是角色的controller的高度 * 0.5 再加上人物和地面的偏移量。这个偏移量是个常量。所以我们在上面声明这两个参数
    var distance = (height * 0.5f) + m_groundOffset;
    // 我们需要检测现在角色脚下的情况，但是我们还需要拿到射线都碰到了什么以便以后使用，所以需要再封装一层函数。
    // 这里的判断是如果脚下有东西 且 垂直速度小于等于0，即有可能没有垂直速度，有可能正在下落
    if (SphereCast(Vector3.down, distance, out var hit) && verticalVelocity.y <= 0)
    {
        // 如果角色不在地面上
        if (!isGrounded)
        {
            // 不在地面上就该下落，这里要检测是否落地
            if (EvaluateLanding(hit))
            {
                // 落地了就进入落地函数
                EnterGround(hit);
            }
            else 
            {
                // 这个函数目前还是空的
                HandleHighLedge(hit);
            }
        }
        // 否则，isGrounded = true时，就要检测这个射线检测到的东西，是否在这个台阶偏移量范围内，是的话就要更新地面了
        else if (IsPointUnderStep(hit.point)) 
        {
            UpdateGround(hit);

            if (Vector3.Angle(hit.normal, Vector3.up) >= controller.slopeLimit)
            {
                // HandleSlopeLimit(hit);
            }
        }
        else
        {
            HandleHighLedge(hit);
        }
    }
    else
    {
        // 如果脚下没东西 或者 垂直速度大于0（人物在上升），执行离开地面的函数
        ExitGround();
    }
}

protected virtual void UpdateGround(RaycastHit hit)
{
    // 更新地面，设定实体的父节点为Platform类型的东西。
    if (isGrounded)
    {
        groundHit = hit;
        groundNormal = groundHit.normal;
        groundAngle = Vector3.Angle(Vector3.up, groundHit.normal);
        localSlopeDirection = new Vector3(groundNormal.x, 0, groundNormal.z).normalized;
        transform.parent = hit.collider.CompareTag(GameTags.Platform) ? hit.transform : null;
    }
}
```

在Player中，我们需要修改一些bug，加上一个函数

```csharp
public virtual void Jump()
{
    var canMultiJump = (jumpCounter > 0) && (jumpCounter < stats.current.multiJumps);
    var canCoyoteJump = (jumpCounter == 0) && (Time.time < lastGroundTime + stats.current.coyoteJumpThreshold);

    if ((isGrounded || canMultiJump || canCoyoteJump) && !holding) // 改这个判断条件，holding的时候不能跳
    {
        if (inputs.GetJumpDown())
        {
            Jump(stats.current.maxJumpHeight);
        }
    } 

    if (inputs.GetJumpUp() && (jumpCounter > 0) && verticalVelocity.y > stats.current.minJumpHeight)
    {
        verticalVelocity = Vector3.up * stats.current.minJumpHeight;
    }
}


// 加上这个函数，player子类还是要多一个判断
protected override bool EvaluateLanding(RaycastHit hit)
{
    return base.EvaluateLanding(hit) && !hit.collider.CompareTag(GameTags.Spring); 
}
```